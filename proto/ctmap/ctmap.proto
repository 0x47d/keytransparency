// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

package ctmap;

import "github.com/google/key-transparency/proto/protobuf/timestamp.proto";


// The VerifiableMapService API 
service VerifiableMapService {
  // GetLeaf retrieves the value stored at a particular index.
  rpc GetLeaf(GetLeafRequest) returns (GetLeafResponse);
  // UpdateLeaf submits a change to the value at index. Clients retry until
  // change is visble in GetLeafResponse.
  rpc UpdateLeaf(UpdateLeafRequest) returns (GetLeafResponse);
}

//
// Data types
//

// MapHead is the head node of the Merkle Tree as well as additional metadata
// for the tree.
message MapHead {
  // realm is the domain identifier for the transparent map.
  string realm = 1;
  // epoch number
  int64 epoch = 2;
  // root is the value of the root node of the merkle tree.
  bytes root = 3;
  // issue_time is the time when this epoch was released. Monotonically increasing.
  protobuf.Timestamp issue_time = 4;
}

// SignedMapHead represents a signed state of the Merkel tree.
message SignedMapHead {
  MapHead map_head = 1;
  // Signature of head, using the signature type of the key.
  // keyed by the first 64 bits bytes of the hash of the key.
  // TODO: Limit 1. Servers should only sign with one key at a time.
  // TODO: Create separate data structure for aggregating signatures from monitors.
  map<string, DigitallySigned> signatures = 2;
}

// DigitallySigned defines a way to sign digital objects.
message DigitallySigned {
  // HashAlgorithm defines the approved ways to hash the object.
  enum HashAlgorithm {
    NONE = 0;
    SHA256 = 4;
    SHA512 = 6;
  }

  // SignatureAlgorithm defines the way to sign the object.
  enum SignatureAlgorithm {
    ANONYMOUS = 0;
    ECDSA = 3;
  }

   HashAlgorithm hash_algorithm = 1;
   SignatureAlgorithm sig_algorithm = 2;
   bytes signature = 3;
}

//
// Request / Response types
//

// GetLeafRequest for a verifiable map leaf.
message GetLeafRequest {
  bytes index = 1;
  uint64 epoch = 2;
}

// GetLeafResponse for a verifiable map leaf.
message GetLeafResponse {
  // leaf_data contains an entry stored in the leaf node.
  bytes leaf_data = 1; 
  // neighbors is a list of all the adjacent nodes along the path
  // from the bottommost node to the head.
  repeated bytes neighbors = 2;
}

// UpdateLeafRequest submits a change for the value at index.
message UpdateLeafRequest {
  bytes index = 1; 
  bytes mutation = 2;
}

// UpdateLeafResponse returns the current value of index.
message UpdateLeafResponse {
  GetLeafResponse proof = 1;
}

// MutationEntry is either a mutation or an epoch advancement.
message MutationEntry {
  oneof type {
    UpdateLeafRequest update = 1;
    bool advance_epoch = 2;
  }
}
