// Code generated by protoc-gen-go.
// source: proto/core/core.proto
// DO NOT EDIT!

/*
Package google_security_e2ekeys_core is a generated protocol buffer package.

It is generated from these files:
	proto/core/core.proto

It has these top-level messages:
	EntryStorage
	EpochInfo
	DomainInfo
	VerifierInfo
*/
package google_security_e2ekeys_core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_security_e2ekeys_v2 "github.com/google/e2e-key-server/proto/v2"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// EntryStorage is what gets serialized to disk / log.
type EntryStorage struct {
	// commitment_timestamp is a sequential update number of the SignedEntryUpdate.
	CommitmentTimestamp uint64 `protobuf:"varint,1,opt,name=commitment_timestamp" json:"commitment_timestamp,omitempty"`
	// entry_update contains a SignedEntryUpdate proto with the actual update
	// contents.
	SignedEntryUpdate *google_security_e2ekeys_v2.SignedEntryUpdate `protobuf:"bytes,2,opt,name=signed_entry_update" json:"signed_entry_update,omitempty"`
	// profile is the serialized protobuf Profile.
	// profile is private and must not be released to verifiers.
	Profile []byte `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	// commitment_key is at least 16 random bytes.
	CommitmentKey []byte `protobuf:"bytes,4,opt,name=commitment_key,proto3" json:"commitment_key,omitempty"`
	// domain allows servers to keep track of multiple trees at once.
	Domain string `protobuf:"bytes,5,opt,name=domain" json:"domain,omitempty"`
}

func (m *EntryStorage) Reset()         { *m = EntryStorage{} }
func (m *EntryStorage) String() string { return proto.CompactTextString(m) }
func (*EntryStorage) ProtoMessage()    {}

func (m *EntryStorage) GetSignedEntryUpdate() *google_security_e2ekeys_v2.SignedEntryUpdate {
	if m != nil {
		return m.SignedEntryUpdate
	}
	return nil
}

// EpochInfo is what gets serialized to disk / log.
type EpochInfo struct {
	// signed_epoch_head is the signed epoch head of the created epoch.
	SignedEpochHead *google_security_e2ekeys_v2.SignedEpochHead `protobuf:"bytes,1,opt,name=signed_epoch_head" json:"signed_epoch_head,omitempty"`
	// last_commitment_timestamp is the timestamp of the last update included in
	// created epoch.
	LastCommitmentTimestamp uint64 `protobuf:"varint,2,opt,name=last_commitment_timestamp" json:"last_commitment_timestamp,omitempty"`
}

func (m *EpochInfo) Reset()         { *m = EpochInfo{} }
func (m *EpochInfo) String() string { return proto.CompactTextString(m) }
func (*EpochInfo) ProtoMessage()    {}

func (m *EpochInfo) GetSignedEpochHead() *google_security_e2ekeys_v2.SignedEpochHead {
	if m != nil {
		return m.SignedEpochHead
	}
	return nil
}

// DomainInfo is the information that need to be baked into an application
// in order to verify information for a domain.
type DomainInfo struct {
	PublicKeys []*google_security_e2ekeys_v2.PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty"`
	// required_sigs is the number of valid signatures to require out of
	// public_keys before considering signed_tree heads legitimate.
	RequiredSigs uint32 `protobuf:"varint,2,opt,name=required_sigs" json:"required_sigs,omitempty"`
	// domain is the doman suffix to use when resolving a user_id to a domain.
	Domain string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
	// api_url is the url prefix to use when querying users on this domain.
	ApiUrl string `protobuf:"bytes,4,opt,name=api_url" json:"api_url,omitempty"`
}

func (m *DomainInfo) Reset()         { *m = DomainInfo{} }
func (m *DomainInfo) String() string { return proto.CompactTextString(m) }
func (*DomainInfo) ProtoMessage()    {}

func (m *DomainInfo) GetPublicKeys() []*google_security_e2ekeys_v2.PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

type VerifierInfo struct {
	PublicKeys []*google_security_e2ekeys_v2.PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty"`
	// required_sigs is the number of valid signatures to require out of
	// public_keys before considering signed_tree heads legitimate.
	RequiredSigs uint32 `protobuf:"varint,2,opt,name=required_sigs" json:"required_sigs,omitempty"`
	// api_url is the url prefix to use when querying users on this domain.
	ApiUrl string `protobuf:"bytes,4,opt,name=api_url" json:"api_url,omitempty"`
	// domain is the doman suffix that this verifier is responsible for.
	Domain string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
}

func (m *VerifierInfo) Reset()         { *m = VerifierInfo{} }
func (m *VerifierInfo) String() string { return proto.CompactTextString(m) }
func (*VerifierInfo) ProtoMessage()    {}

func (m *VerifierInfo) GetPublicKeys() []*google_security_e2ekeys_v2.PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}
