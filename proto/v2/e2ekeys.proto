// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.security.e2ekeys.v2;

option java_package = "com.google.security.e2ekeys.v2";
option java_multiple_files = true;
option java_outer_classname = "E2EKeysProto";

import "google/api/annotations.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// The E2EKeyService API represents a directory of public keys.
// The key server has the following verifiable security properties:
// - The server keeps a single history of the directory.
// - The server gives consistent answers to queries regardless of audience.
//    - The server publishes a signed tree root (STR) of all its data every
//      epoch.
//    - Users can verify that a given entry is contained in that STR.
//    - Only one entry in the server is valid for any particular user id.
//
// The API defines the following resource model:
//
// - The API has a collection of [User][google.security.e2ekeys.v2.User]
//   resources named `/users/*`.
//
// - Each User has a collection of
//  [SignedKey][google.security.e2ekeys.v2.SignedKey] resources named by
//  `/users/*/keys/*`
//
service E2EKeyService {
  // GetUser returns a user's keys, the comittment in the merkle tree, a
  // proof that there is only one entry for this user, and a proof that it is
  // the same data being provided to everyone else.
  // GetUser also supports querying past values by setting the epoch field.
  rpc GetUser(GetUserRequest) returns (EntryProfileAndProof) {
    option (google.api.http) = { get: "/v2/users/{user_id}" };
  }

  // ListUserHistory returns a list of UserProofs covering a period of time.
  rpc ListUserHistory(ListUserHistoryRequest) returns (ListUserHistoryResponse)
  {
    option (google.api.http) = { get: "/v2/users/{user_id}/history" };
  }

  // blocking?
  rpc UpdateUser(UpdateUserRequest) returns (protobuf.Empty)
    option (google.api.http) = {
      put: "/v2/users/{user_id}"
      body: "update"
    };
    option (google.api.method_visibility).restriction = "GOOGLE_INTERNAL";
  }

  // from epoch to epoch, list of STHs
  rpc ListSTH(ListSTHRequest) returns (ListSTHResponse) {
    option (google.api.http) = { get: "/v2/sth/" };
  }
  // from epoch to epoch list of SignedEntryUpdate
  rpc ListUpdate(ListUpdateRequest) returns (ListUpdateResponse) {
    option (google.api.http) = { get: "/v2/update/" };
  }
}

//
// Data types.
//

// Key contains the public key and metadata.
message Key {
  // Format for the key.
  Format format = 1;  // Required.
  // The encryption key itself.
  bytes key = 2;  // Required.
  // The name of the application this key is for.
  string app_id = 3;  // Required.
  // key_id is implied from the hash of the key material itself.

  // Key Formats.
  enum Format {
    // Unknown key format.
    UNKNOWN = 0;
    // Eliptic Curve Public Key.
    ECC = 1;
    // Raw bytes from decoded PGP key ring ascii armor.
    PGP_KEYRING = 2;
  }
}

// Profile contains data hidden behind the crypto comitment.
message Profile {
  // Nonce prevents an adversary from brute forcing nodes to the side of a user.
  uint64 nonce = 1;
  // key_list is the full list of keys in the profile.
  repeated Key key_list = 2;
  // TODO: create more efficient ways of compacting the key_list.
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.  The hashed value of Entry is:
// H(entry_key || profile_comitment ||  update_count || index)
message Entry {
  // entry_key allows verifiers to validate updates to Entry.
  key entry_key = 1;
  // profile_comitment is a cryptographic commitment to the Profile of the form
  // HMAC(nonce, serialized_profile)
  bytes profile_comitment = 2;
  // update_count prevents replaying old signed EntryUpdates.
  uint64 update_count = 3;
  // index is the location in the merkle tree for this entry.
  // If signing keys are not unique per user, we need to tie updates to a
  // particular profile.
  string index = 4;
}

// RFC 5246 Signature from Certificate Transparency.
message DigitallySigned {
  enum HashAlgorithm {
    NONE = 0;
    MD5 = 1;
    SHA1 = 2;
    SHA224 = 3;
    SHA256 = 4;
    SHA384 = 5;
    SHA512 = 6;
  }

  enum SignatureAlgorithm {
    ANONYMOUS = 0;
    RSA = 1;
    DSA = 2;
    ECDSA = 3;
  }

  // 1 byte
  optional HashAlgorithm hash_algorithm = 1 [ default = NONE ];
  // 1 byte
  optional SignatureAlgorithm sig_algorithm = 2 [ default = ANONYMOUS ];
  // 0..2^16-1 bytes
  optional bytes signature = 3;
}

message SignedEntryUpdate {
  // Signature of entry, by the entry_key inside entry.
  // Proves ownership of new key.
  DigitallySigned signature_new = 2;
  // Signature of entry, by the entry_key from the previous epoch.
  // Proves the the correct owner is making this change.
  DigitallySigned signature_old = 3;
  // entry is the serialized protobuf Entry.
  bytes entry = 3;
}

// EntryUpdate is the proto a client sends.
message EntryUpdateRequest {
  // silned_update authorizes the change to profile.
  SignedEntryUpdate signed_update = 1;
  // profile is the serialized protobuf Profile.
  // profile is private and must not be released to verifiers.
  bytes profile = 4;
}


// EntryStorage is what gets serialized to disk / log.
message EntryStorage {
  // epoch allows entry updates to be self contained. Epoch is server supplied.
  // epoch is the epoch at which this update should be inserted into the merkle
  // tree.
  uint64 epoch = 1;
  // sequence is a sequential update number supplied by consistent store.
  // Save inside proto or outside the proto?
  // Need to be able to index this object by sequence number.
  uint64 sequence = 3;
  // entry_update is the actual update contents.
  EntryUpdate entry_update = 2;
  // profile is the serialized protobuf Profile.
  // profile is private and must not be released to verifiers.
  bytes profile = 4;
  // domain allows servers to keep track of multiple trees at once.
  string domain = 5;
}

message EntryAndProof {
  // Entry contains the public portion of the user's data, and a comitment to
  // profile.
  Entry entry = 1;
  // Profile contains the user's keys.
  bytes profile = 2;
  // merkle_tree_neighbors is a list of all the adacent nodes along the path
  // from the bottommost node to the root.
  repeated bytes merkle_tree_neighbors = 3;
  // The signed tree head.
  SignedTreeHead str = 3;
  // index_signature is the signed portion the unpredictable verifiable
  // function on user_id. If H(index_signature) != entry.index, but they share
  // a common prefix of len(merkle_tree_neighbors), this is a proof of
  // non-existance for user_id.
  bytes index_signature = 4;
}

// SignedTreeHead represents a signed state of the Merkel tree.
message SignedTreeHead {
  // Signature of this epoch's root hash.
  DigitallySigned root_sig = 1;
  // Serialized TreeHead.
  bytes head = 2;
}

// TreeHead is the head node of the Merkle Tree, incorporating left and right
// sub-branches as well as additional metadata for the tree.
message TreeHead {
  // epoch number
  uint64 epoch = 1;
  // The timestamp of this epoch.
  google.protobuf.Timestamp current_time = 2;
  // Hash of previous STH.
  bytes previous_sth = 3;
  // The value of the root node of the merkle tree.
  bytes head = 4;
}
//
// RPC request/response messages.
//

// Get request for a user object.
message GetUserRequest {
  // Absence of the time field indicates a request for the current value.
  uint64 epoch = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
  // Only return the keys belonging to this app.
  string app_id = 3;
}

// Get a list of historical values for a user.
message ListUserHistoryRequest {
  // The user identifier.
  string user_id = 1;
  // from_epoch is the starting epcoh.
  uint64 start_epoch = 2;
  // The maximum number of entries to return.
  int32 page_size = 3;
  // compression_mode allows a user to verify thier own entries.
  Mode compression_mode = 4;
  enum Mode {
    // FULL returns every epoch.
    FULL = 0;
    // Fast returns an STH for every epoch. For every epoch n where update_count
    // is incremented, Fast returns full proofs for epoch n and n-1.
    FAST = 1;
  }
}

// A paginated history of values for a user.
message ListUserHistoryResponse {
  // The list of values this user_id has contained over time.
  repeated EntryProfileAndProof values = 1;
  // The next time to query for pagination.
  uint64 next_epoch = 2;
}

// Update a key.
message UpdateUserRequest {
  // The User to update.
  string user_id = 1;
  // The new value of the key.
  EntryUpdateRequest update = 2;
}

// Delete a key.
message DeleteKeyRequest {
  // The User to update.
  string user_id = 2;
  // The key to delete.
  string key_id = 4;
}

message ListSTHRequest {
  // from_epoch is the starting epcoh.
  uint64 start_epoch = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListSTHResponse {
  repeated SignedTreeHead heads = 1;
}

message ListUpdateRequest {
  // start_sequence is the starting sequence number.
  uint64 start_sequence = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListUpdateResponse {
  repeated SignedEntryUpdate updates = 1;
}
