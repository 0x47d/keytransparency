// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.security.e2ekeys.v2;

option java_package = "com.google.security.e2ekeys.v2";
option java_multiple_files = true;
option java_outer_classname = "E2EKeysProto";

import "google/api/annotations.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// The E2EKeyService API represents a directory of public keys.
// The key server has the following verifiable security properties:
// - The server keeps a single history of the directory.
// - The server gives consistent answers to queries regardless of audience.
//    - The server publishes a signed tree root (STR) of all its data every
//      epoch.
//    - Users can verify that a given entry is contained in that STR.
//    - Only one entry in the server is valid for any particular user id.
//
// The API defines the following resource model:
//
// - The API has a collection of [User][google.security.e2ekeys.v2.User]
//   resources named `/users/*`.
//
// - Each User has a collection of
//  [SignedKey][google.security.e2ekeys.v2.SignedKey] resources named by
//  `/users/*/keys/*`
//
service E2EKeyService {
  // GetUser returns a user's data entry, a proof that there is only one entry
  // for this user, and a proof that it is the same data being provided to
  // everyone else.
  // GetUser also supports querying past values by setting the epoch field.
  rpc GetUser(GetUserRequest) returns (UserProof) {
    option (google.api.http) = { get: "/v2/users/{user_id}" };
  }

  // ListUserHistory returns a list of UserProofs covering a period of time.
  rpc ListUserHistory(ListUserHistoryRequest) returns (ListUserHistoryResponse) {
    option (google.api.http) = { get: "/v2/users/{user_id}/history" };
  }

  // Delete / Create cycles are prohibited for user entries.  Once created, a
  // user's entry must have a contiguous history.

  // CreateKey promises to create a new key for a user on the next epoch.
  // Multiple new keys can be created each epoch. Clients must verify that each
  // promise is represented within the STR on the next epoch.
  rpc CreateKey (CreateKeyRequest) returns (KeyPromise) {
    option (google.api.http) = {
      post: "/v2/users/{user_id}/keys"
      body: "signed_key"
    };
  }

  // UpdateKey updates a key.
  rpc UpdateKey (UpdateKeyRequest) returns (KeyPromise) {
    option (google.api.http) = {
      put: "/v2/users/{user_id}/keys/{key_id}"
      body: "signed_key"
    };
  }

  // DeleteKey deletes a key. Returns NOT_FOUND if the key does not exist.
  rpc DeleteKey(DeleteKeyRequest) returns (protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v2/users/{user_id}/keys/{key_id}"
    };
  }
}

//
// Data types.
//

// A User entry along with its proof.
message UserProof {
  // The user object
  User user = 1;
  // The authentication path to the epoch root.
  Proof proof = 2;
  // promises is a list of keys that the server has accepted, but hasn't merged
  // into the STR yet.
  repeated KeyPromise promises = 4;
}

// The User is the leaf object in the binary Merkle Tree. Its unique location
// in the tree is identified by a hash of an verifiable unpredictable function
// on the user_id. The value of the user leaf node is
// H("leaf" || H(VUF) || HMAC(nonce,  H(Meta) || KeyList))
message User {
  // Metadata associated with this user.
  UserMeta meta = 1;
  // Nonce prevents an adversary from brute forcing nodes to the side of a user.
  bytes nonce = 2;
  // KeyList represents all the user's keys in a compressed form.
  KeyList key_list = 3;

  // KeyList is a container for a representing all the user's keys, when only a
  // few of them have been requested by a client application.
  // The KeyList value is equal to H(k1) || H(k2) ... || H(kn)
  message KeyList {
    // signed_keys is an ordered array of SignedKeys for this user. All keys for
    // a user must be present in either signed_keys or hashed_signed_keys.
    // Omitted values are null.
    repeated SignedKey signed_keys = 2;
    // hashed_signed_keys is an ordered array of H(SignedKey)s for this user.
    repeated bytes hashed_signed_keys = 3;
  }
}

// Meta is a container for user metadata.
message UserMeta {
  // reset_count is a monotonically increasing number representing the number
  // of times this account has been reset. A change in this number generates
  // a warning the next time a client attempts to message this user.
  uint32 reset_count = 1;

  // Placeholder for additional provider specific metadata.
  google.protobuf.Any provider_metadata = 2;
}

// SignedKey contains a Key and associated signatures, showing continuity of
// key ownership.
message SignedKey{
  // A key with metadata.
  Key key = 1;

  // Key contains the public key and metadata.
  // When a user wishes to revoke a key that has been compromised, add a new key
  // signed by a current key, then delete the compromised key.
  // Keys not present in the current STR are considered revoked.
  message Key {
    // Format for the key.
    Format format = 1;  // Required.
    // The encryption key itself.
    bytes key = 2;  // Required.
    // The name of the application this key is for.
    string app_id = 3;  // Required.
    // Timestamp of when this key was added.  Verified by server.
    google.protobuf.Timestamp creation_time = 4; // Required.

    // Key Formats.
    enum Format {
      // Unknown key format.
      UNKNOWN = 0;
      // Eliptic Curve Public Key.
      ECC = 1;
      // Raw bytes from decoded PGP key ring ascii armor.
      PGP_KEYRING = 2;
    }
  }
  // Signature of key, by the current key. Proves ownership of new key.
  Signature signature_current = 2;
  // Signature of key, by either: 1) the same key_id in the previous epoch, proving
  // proving that the correct owner of the key is making the rotation or 2) a
  // different key in the previous epoch, proving that the owner of the accout
  // is adding the new key.
  Signature signature_old = 3;
  // key_id is the PGP fingerprint, or for ecc, the hash of the ecc key.
  // Used to uniquely identify the key.
  string key_id = 4; // Filled by server.
}

// Signature represents a digital signature of the hash of an object.
message Signature {
  // The key used for signing.
  string key_id = 1;
  // The data to be signed.  Usually the hash of a serialized proto.
  bytes signed_data = 2;
  // The serialized ECDSA signature.
  bytes signature = 3;
}

// A key object, paired with a timestamp.
message SignedKeyTimestamp {
  // The time this object was created.
  google.protobuf.Timestamp creation_time = 1;
  // The signed new key.
  SignedKey signed_key = 2;
  // The user this key is for.
  string user_id = 3;
  // The index in the tree for this user.
  bytes vuf = 4;
}

// A promise to include a given key in the STR on the next epoch.
message KeyPromise {
  // The key and timestamp.
  SignedKeyTimestamp signed_key_timestamp = 1;
  // A signature over the key and timestamp.
  Signature signature = 2;
}

// A Proof provides an authentication path through the Merkle Tree that
// proves that an item is present in the STR.
message Proof {
  // Neighbors is a list of all the adjacent nodes along the path from the leaf
  // object to the root.  To save space, hashes for empty subtrees are omitted.
  repeated bytes neighbors = 1;
  // The signed tree root (STR).
  SignedTreeRoot str = 3;
  // Output of an verifiable unpredictable function on user_id.
  // Prevents an adversary from brute forcing a user's index in the tree.
  bytes vuf = 4;
}

// SignedTreeRoot represents a signed state of the Merkel tree.
message SignedTreeRoot {
  // Signature of this epoch's root hash.
  Signature root_sig = 1;
  // Hash of this epoch's root.
  bytes root_hash = 2;
  // Value of this epoch's root.
  TreeRoot root = 3;
}

// TreeRoot is the head node of the Merkle Tree, incorporating left and right
// sub-branches as well as additional metadata for the tree.
message TreeRoot {
  // The timestamp of the current epoch.
  google.protobuf.Timestamp current_time = 1;
  // The timestamp of the previous epoch.
  google.protobuf.Timestamp previous_time = 2;
  // Hash of previous root.
  bytes previous_root = 3;
  // Value of the left branch.  H(sub0).
  bytes left = 4;
  // Value of the right branch. H(sub1).
  bytes right = 5;
}

//
// RPC request/response messages.
//

// Get request for a user object.
message GetUserRequest {
  // Absence of the time field indicates a request for the current value.
  google.protobuf.Timestamp time = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
  // Only return the keys belonging to this app.
  string app_id = 3;
}

// Get a list of historical values for a user.
message ListUserHistoryRequest {
  // The user identifier.
  string user_id = 1;
  // The time at which to start pagination.
  google.protobuf.Timestamp starting_time = 2;
  // The maximum number of entries to return.
  int32 page_size = 4;
}

// A paginated history of values for a user.
message ListUserHistoryResponse {
  // The list of values this user_id has contained over time.
  repeated UserProof values = 1;
  // The next time to query for pagination.
  google.protobuf.Timestamp next_time = 2;
}

// Create a new key.
message CreateKeyRequest {
  // The User to requset for.
  string user_id = 1;
  // The new key.
  SignedKey signed_key = 2;
}

// Update a key.
message UpdateKeyRequest {
  // The User to update.
  string user_id = 2;
  // The key to update.
  string key_id = 4;
  // The new value of the key.
  SignedKey signed_key = 5;
}

// Delete a key.
message DeleteKeyRequest {
  // The User to update.
  string user_id = 2;
  // The key to delete.
  string key_id = 4;
}
