// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.security.e2ekeys.v2;

import "google/protobuf/timestamp.proto";

// The E2EKeyService API represents a directory of public keys.
// The API defines the following resource model:
//
// - The API has a collection of  [Entry][google.security.e2ekeys.v2.Entry]
//   resources named `/entries/*`.
//
// - Entries have a collection of historical
//   [Entry][google.security.e2ekeys.v2.Entry] resources named 
//   `/entries/*/history`.
//
service E2EKeyService {
  // GetEntry returns a user's entry in the Merkle Tree. Entries contain 
  // signed commitments to a profile, which is also returned.
  rpc GetEntry(GetEntryRequest) returns (GetEntryResponse);

  // ListEntryHistory returns a list of GetEntryRespons covering several epochs.
  rpc ListEntryHistory(ListEntryHistoryRequest) returns (ListEntryHistoryResponse);

  // blocking or polling?
  // UpdateEntry submits a SignedEntryUpdate.  Returns empty until this update
  // has been included in an epoch.  Clients must retry until this function 
  // returns a proof.
  rpc UpdateEntry(UpdateEntryRequest) returns (UpdateEntryResponse);

  // List the Signed Epoch Heads, from epoch to epoch.
  rpc ListSEH(ListSEHRequest) returns (ListSEHResponse);

  // List the EntryUpdates by update number.
  rpc ListUpdate(ListUpdateRequest) returns (ListUpdateResponse);

  // ListSteps combines SEH and EntryUpdates into single list.
  rpc ListSteps(ListStepsRequest) returns (ListStepsResponse);
}

//
// Data types.
//

// SignedEpochHead represents a signed state of the Merkel tree.
message SignedEpochHead {
  // Serialized EpochHead.
  bytes epoch_head = 1;
  // Signature of head, using the signature type of the key.
  // keyed by the first 64 bits bytes of the hash of the key.
  map<fixed64, bytes> signatures = 2;
}

// EpochHead is the head node of the Merkle Tree as well as additional metadata 
// for the tree.
message EpochHead {
  // Realm is the domain...
  string realm = 1;
  // Epoch number
  uint64 epoch = 2;
  // Root is the value of the root node of the merkle tree.
  bytes root = 3;
  // IssueTime is the time when this epoch was released. All epochs for the
  // same keyserver MUST have non-decreasing IssueTimes.
  google.protobuf.Timestamp issue_time = 4;
  // Hash of previous SEH. 64 bytes of SHA3-SHAKE256.
  bytes previous_epoch_head_hash = 5;
}

message GetEntryResponse {
  // UserId supports sending this as a complete proof to a third party. 
  string user_id = 1; // Optional.
  // IndexProof is the proof for VUF(user_id). 
  bytes index_proof = 2;
  // Index is the output of VUF on (user_id).
  // If index != entry.index,  but they share a common prefix of 
  // len(merkle_tree_neighbors), this is a proof of absence for user_id.
  bytes index = 3;
  // The signed epoch head.  A server may choose to return multiple signatures
  // of the same head for the same epoch. A client MUST NOT consider the
  // presence of surplus or invalid epoch heads in this field an error.
  repeated SignedEpochHead signed_epoch_heads = 4; // Optional.
  // MerkleTreeNeighbors is a list of all the adjacent nodes along the path
  // from the bottommost node to the head.
  repeated bytes merkle_tree_neighbors = 5;
  // Entry contains the public portion of the user's data, and a comitment to
  // profile.
  Entry entry = 6;
  // Profile contains the user's keys.
  bytes profile = 7;
  // CommitmentKey is 16 random bytes.
  bytes commitment_key = 8;
}

// Step is a combined, ordered list of SignedEntryUpdates and SignedEpochHeads
// which are made available to verifiers.
message Step {
  oneof type {
    // entry_changed contains a serialized SignedEntryUpdate.
    bytes entry_changed = 1;
    SignedEpochHead signed_epoch_head = 2;
  }
  // epoch of this udpate.
  uint64 epoch = 3;
  // commitment_timestamp is the ordered commitment_timestamp of this step.
  uint64 commitment_timestamp = 4;
}

// SignedEntryUpdate is what users provide to update their profiles.
// A serialized SignedEntryUpdate is used as the leaf value in the MerkleTree.
message SignedEntryUpdate {
  // NewEntry is the serialized protobuf Entry.
  bytes new_entry = 1;
  // Signature of entry, by the entry_key inside entry AND the old key from the
  // previous epoch. The first proves ownership of new epoch key, and the
  // second proves the the correct owner is making this change.
  map<fixed64, bytes> signatures = 2;
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.
message Entry {
  // Index is the location in the merkle tree for this entry.
  // If signing keys are not unique per user, we need to tie updates to a
  // particular profile.
  bytes index = 1;
  // UpdateCount prevents replaying old signed EntryUpdates.
  // not nessesarilly incremented by only one each update.
  uint64 update_count = 2;
  // EntryKey allows verifiers to validate updates to Entry.
  repeated PublicKey entry_key = 3;
  // profile_commitment is a cryptographic commitment to the Profile of the form
  // HMAC(profile_commitment_key, serialized_profile)
  bytes profile_commitment = 4;
  // Update policy: new Entry must be signed by at least one key from entry_key 
  // in previous epoch. 
}

// Profile contains data hidden behind the crypto comitment.
message Profile {
  // Keys is a map of appIds to keys.
  map<string, bytes> keys = 1;
}

// PublicKey defines a key this domain uses to sign EpochHeads with.
message PublicKey {
  // KeyFormats from Keyczar.
  oneof key_type {
    bytes ed25519 = 1; // 32 bytes (<http://ed25519.cr.yp.to/>)
    bytes rsa_verifying_sha256_2048 = 2;
    bytes ecdsa_verifying_p256 = 3;
  }
}

//
// RPC request/response messages.
//

// Get request for a user object.
message GetEntryRequest {
  // Absence of the time field indicates a request for the current value.
  uint64 epoch = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
  // TODO(cesarghali): implement app_id filtering.
  // Only return the keys belonging to this app.
  string app_id = 3;
  // TODO: implement key_hash filtering.
  // Only return SEH's that are signed by these keys.
  repeated fixed64 trusted_keys = 4;
}

// Get a list of historical values for a user.
message ListEntryHistoryRequest {
  // The user identifier.
  string user_id = 1;
  // from_epoch is the starting epcoh.
  uint64 start_epoch = 2;
  // The maximum number of entries to return.
  int32 page_size = 3;
  // compression_mode allows a user to verify thier own entries.
  // TODO: optional compression mode?
}

// A paginated history of values for a user.
message ListEntryHistoryResponse {
  // The list of values this user_id has contained over time.
  repeated GetEntryResponse values = 1;
  // The next time to query for pagination.
  uint64 next_epoch = 2;
}

// Update a user's profile.
message UpdateEntryRequest {
  // UserID specifies the id for the new account to be registered. 
  string user_id = 1; // Optional.
  // SignedEntryUpdate authorizes the change to profile.
  SignedEntryUpdate signed_entry_update = 2;
  // Profile is the serialized protobuf Profile.
  // Profile is private and must not be released to verifiers.
  bytes profile = 3;
  // CommitmentKey is 16 random bytes.
  bytes commitment_key = 4;

  // DkimProof is used to vouch for the validity of a new registration.
  // Used when OAuth is not used.
  bytes dkim_proof = 1001; // Optional.
}

// UpdateEntryResponse contains a proof once the update has been included in 
// the Merkel Tree.
message UpdateEntryResponse {
  GetEntryResponse proof = 1;
}


message ListSEHRequest {
  // from_epoch is the starting epcoh.
  uint64 start_epoch = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListSEHResponse {
  repeated SignedEpochHead heads = 1;
}

message ListUpdateRequest {
  // start_commitment_timestamp is the starting commitment timestamp.
  uint64 start_commitment_timestamp = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListUpdateResponse {
  // updates contains a serialized SignedEntryUpdate.
  repeated bytes updates = 1;
}

message ListStepsRequest {
  // start_commitment_timestamp is the starting commitment timestamp.
  uint64 start_commitment_timestamp = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListStepsResponse {
  repeated Step steps = 1;
}
