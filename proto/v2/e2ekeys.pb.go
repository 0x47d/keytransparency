// Code generated by protoc-gen-go.
// source: proto/v2/e2ekeys.proto
// DO NOT EDIT!

/*
Package google_security_e2ekeys_v2 is a generated protocol buffer package.

It is generated from these files:
	proto/v2/e2ekeys.proto

It has these top-level messages:
	SignedEpochHead
	EpochHead
	GetEntryResponse
	Step
	SignedEntryUpdate
	Entry
	Profile
	PublicKey
	GetEntryRequest
	ListEntryHistoryRequest
	ListEntryHistoryResponse
	UpdateEntryRequest
	UpdateEntryResponse
	ListSEHRequest
	ListSEHResponse
	ListUpdateRequest
	ListUpdateResponse
	ListStepsRequest
	ListStepsResponse
*/
package google_security_e2ekeys_v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "google/protobuf"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// SignedEpochHead represents a signed state of the Merkel tree.
type SignedEpochHead struct {
	// Serialized EpochHead.
	EpochHead []byte `protobuf:"bytes,1,opt,name=epoch_head,proto3" json:"epoch_head,omitempty"`
	// Signature of head, using the signature type of the key.
	// keyed by the first 64 bits bytes of the hash of the key.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()         { *m = SignedEpochHead{} }
func (m *SignedEpochHead) String() string { return proto.CompactTextString(m) }
func (*SignedEpochHead) ProtoMessage()    {}

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// EpochHead is the head node of the Merkle Tree as well as additional metadata
// for the tree.
type EpochHead struct {
	// Realm is the domain...
	Realm string `protobuf:"bytes,1,opt,name=realm" json:"realm,omitempty"`
	// Epoch number
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch" json:"epoch,omitempty"`
	// Root is the value of the root node of the merkle tree.
	Root []byte `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// IssueTime is the time when this epoch was released. All epochs for the
	// same keyserver MUST have non-decreasing IssueTimes.
	IssueTime *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=issue_time" json:"issue_time,omitempty"`
	// Hash of previous SEH. 64 bytes of SHA3-SHAKE256.
	PreviousEpochHeadHash []byte `protobuf:"bytes,5,opt,name=previous_epoch_head_hash,proto3" json:"previous_epoch_head_hash,omitempty"`
}

func (m *EpochHead) Reset()         { *m = EpochHead{} }
func (m *EpochHead) String() string { return proto.CompactTextString(m) }
func (*EpochHead) ProtoMessage()    {}

func (m *EpochHead) GetIssueTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return nil
}

type GetEntryResponse struct {
	// UserId supports sending this as a complete proof to a third party.
	UserId string `protobuf:"bytes,1,opt,name=user_id" json:"user_id,omitempty"`
	// IndexProof is the proof for VUF(user_id).
	IndexProof []byte `protobuf:"bytes,2,opt,name=index_proof,proto3" json:"index_proof,omitempty"`
	// Index is the output of VUF on (user_id).
	// If index != entry.index,  but they share a common prefix of
	// len(merkle_tree_neighbors), this is a proof of absence for user_id.
	Index []byte `protobuf:"bytes,3,opt,name=index,proto3" json:"index,omitempty"`
	// The signed epoch head.  A server may choose to return multiple signatures
	// of the same head for the same epoch. A client MUST NOT consider the
	// presence of surplus or invalid epoch heads in this field an error.
	SignedEpochHeads []*SignedEpochHead `protobuf:"bytes,4,rep,name=signed_epoch_heads" json:"signed_epoch_heads,omitempty"`
	// MerkleTreeNeighbors is a list of all the adjacent nodes along the path
	// from the bottommost node to the head.
	MerkleTreeNeighbors [][]byte `protobuf:"bytes,5,rep,name=merkle_tree_neighbors,proto3" json:"merkle_tree_neighbors,omitempty"`
	// Entry contains the public portion of the user's data, and a comitment to
	// profile.
	Entry *Entry `protobuf:"bytes,6,opt,name=entry" json:"entry,omitempty"`
	// Profile contains the user's keys.
	Profile []byte `protobuf:"bytes,7,opt,name=profile,proto3" json:"profile,omitempty"`
	// CommitmentKey is 16 random bytes.
	CommitmentKey []byte `protobuf:"bytes,8,opt,name=commitment_key,proto3" json:"commitment_key,omitempty"`
}

func (m *GetEntryResponse) Reset()         { *m = GetEntryResponse{} }
func (m *GetEntryResponse) String() string { return proto.CompactTextString(m) }
func (*GetEntryResponse) ProtoMessage()    {}

func (m *GetEntryResponse) GetSignedEpochHeads() []*SignedEpochHead {
	if m != nil {
		return m.SignedEpochHeads
	}
	return nil
}

func (m *GetEntryResponse) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

// Step is a combined, ordered list of SignedEntryUpdates and SignedEpochHeads
// which are made available to verifiers.
type Step struct {
	// Types that are valid to be assigned to Type:
	//	*Step_EntryChanged
	//	*Step_SignedEpochHead
	Type isStep_Type `protobuf_oneof:"type"`
	// epoch of this udpate.
	Epoch uint64 `protobuf:"varint,3,opt,name=epoch" json:"epoch,omitempty"`
	// commitment_timestamp is the ordered commitment_timestamp of this step.
	CommitmentTimestamp uint64 `protobuf:"varint,4,opt,name=commitment_timestamp" json:"commitment_timestamp,omitempty"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}

type isStep_Type interface {
	isStep_Type()
}

type Step_EntryChanged struct {
	EntryChanged []byte `protobuf:"bytes,1,opt,name=entry_changed,proto3,oneof"`
}
type Step_SignedEpochHead struct {
	SignedEpochHead *SignedEpochHead `protobuf:"bytes,2,opt,name=signed_epoch_head,oneof"`
}

func (*Step_EntryChanged) isStep_Type()    {}
func (*Step_SignedEpochHead) isStep_Type() {}

func (m *Step) GetType() isStep_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Step) GetEntryChanged() []byte {
	if x, ok := m.GetType().(*Step_EntryChanged); ok {
		return x.EntryChanged
	}
	return nil
}

func (m *Step) GetSignedEpochHead() *SignedEpochHead {
	if x, ok := m.GetType().(*Step_SignedEpochHead); ok {
		return x.SignedEpochHead
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Step) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Step_OneofMarshaler, _Step_OneofUnmarshaler, []interface{}{
		(*Step_EntryChanged)(nil),
		(*Step_SignedEpochHead)(nil),
	}
}

func _Step_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Step)
	// type
	switch x := m.Type.(type) {
	case *Step_EntryChanged:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.EntryChanged)
	case *Step_SignedEpochHead:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SignedEpochHead); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Step.Type has unexpected type %T", x)
	}
	return nil
}

func _Step_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Step)
	switch tag {
	case 1: // type.entry_changed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &Step_EntryChanged{x}
		return true, err
	case 2: // type.signed_epoch_head
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SignedEpochHead)
		err := b.DecodeMessage(msg)
		m.Type = &Step_SignedEpochHead{msg}
		return true, err
	default:
		return false, nil
	}
}

// SignedEntryUpdate is what users provide to update their profiles.
// A serialized SignedEntryUpdate is used as the leaf value in the MerkleTree.
type SignedEntryUpdate struct {
	// NewEntry is the serialized protobuf Entry.
	NewEntry []byte `protobuf:"bytes,1,opt,name=new_entry,proto3" json:"new_entry,omitempty"`
	// Signature of entry, by the entry_key inside entry AND the old key from the
	// previous epoch. The first proves ownership of new epoch key, and the
	// second proves the the correct owner is making this change.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEntryUpdate) Reset()         { *m = SignedEntryUpdate{} }
func (m *SignedEntryUpdate) String() string { return proto.CompactTextString(m) }
func (*SignedEntryUpdate) ProtoMessage()    {}

func (m *SignedEntryUpdate) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.
type Entry struct {
	// Index is the location in the merkle tree for this entry.
	// If signing keys are not unique per user, we need to tie updates to a
	// particular profile.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// UpdateCount prevents replaying old signed EntryUpdates.
	// not nessesarilly incremented by only one each update.
	UpdateCount uint64 `protobuf:"varint,2,opt,name=update_count" json:"update_count,omitempty"`
	// EntryKey allows verifiers to validate updates to Entry.
	EntryKey []*PublicKey `protobuf:"bytes,3,rep,name=entry_key" json:"entry_key,omitempty"`
	// profile_commitment is a cryptographic commitment to the Profile of the form
	// HMAC(profile_commitment_key, serialized_profile)
	ProfileCommitment []byte `protobuf:"bytes,4,opt,name=profile_commitment,proto3" json:"profile_commitment,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}

func (m *Entry) GetEntryKey() []*PublicKey {
	if m != nil {
		return m.EntryKey
	}
	return nil
}

// Profile contains data hidden behind the crypto comitment.
type Profile struct {
	// Keys is a map of appIds to keys.
	Keys map[string][]byte `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}

func (m *Profile) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// PublicKey defines a key this domain uses to sign EpochHeads with.
type PublicKey struct {
	// KeyFormats from Keyczar.
	//
	// Types that are valid to be assigned to KeyType:
	//	*PublicKey_Ed25519
	//	*PublicKey_RsaVerifyingSha256_2048
	//	*PublicKey_EcdsaVerifyingP256
	KeyType isPublicKey_KeyType `protobuf_oneof:"key_type"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}

type isPublicKey_KeyType interface {
	isPublicKey_KeyType()
}

type PublicKey_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,1,opt,name=ed25519,proto3,oneof"`
}
type PublicKey_RsaVerifyingSha256_2048 struct {
	RsaVerifyingSha256_2048 []byte `protobuf:"bytes,2,opt,name=rsa_verifying_sha256_2048,proto3,oneof"`
}
type PublicKey_EcdsaVerifyingP256 struct {
	EcdsaVerifyingP256 []byte `protobuf:"bytes,3,opt,name=ecdsa_verifying_p256,proto3,oneof"`
}

func (*PublicKey_Ed25519) isPublicKey_KeyType()                 {}
func (*PublicKey_RsaVerifyingSha256_2048) isPublicKey_KeyType() {}
func (*PublicKey_EcdsaVerifyingP256) isPublicKey_KeyType()      {}

func (m *PublicKey) GetKeyType() isPublicKey_KeyType {
	if m != nil {
		return m.KeyType
	}
	return nil
}

func (m *PublicKey) GetEd25519() []byte {
	if x, ok := m.GetKeyType().(*PublicKey_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *PublicKey) GetRsaVerifyingSha256_2048() []byte {
	if x, ok := m.GetKeyType().(*PublicKey_RsaVerifyingSha256_2048); ok {
		return x.RsaVerifyingSha256_2048
	}
	return nil
}

func (m *PublicKey) GetEcdsaVerifyingP256() []byte {
	if x, ok := m.GetKeyType().(*PublicKey_EcdsaVerifyingP256); ok {
		return x.EcdsaVerifyingP256
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PublicKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _PublicKey_OneofMarshaler, _PublicKey_OneofUnmarshaler, []interface{}{
		(*PublicKey_Ed25519)(nil),
		(*PublicKey_RsaVerifyingSha256_2048)(nil),
		(*PublicKey_EcdsaVerifyingP256)(nil),
	}
}

func _PublicKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PublicKey)
	// key_type
	switch x := m.KeyType.(type) {
	case *PublicKey_Ed25519:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Ed25519)
	case *PublicKey_RsaVerifyingSha256_2048:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.RsaVerifyingSha256_2048)
	case *PublicKey_EcdsaVerifyingP256:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.EcdsaVerifyingP256)
	case nil:
	default:
		return fmt.Errorf("PublicKey.KeyType has unexpected type %T", x)
	}
	return nil
}

func _PublicKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PublicKey)
	switch tag {
	case 1: // key_type.ed25519
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyType = &PublicKey_Ed25519{x}
		return true, err
	case 2: // key_type.rsa_verifying_sha256_2048
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyType = &PublicKey_RsaVerifyingSha256_2048{x}
		return true, err
	case 3: // key_type.ecdsa_verifying_p256
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyType = &PublicKey_EcdsaVerifyingP256{x}
		return true, err
	default:
		return false, nil
	}
}

// Get request for a user object.
type GetEntryRequest struct {
	// Absence of the time field indicates a request for the current value.
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch" json:"epoch,omitempty"`
	// User identifier. Most commonly an email address.
	UserId string `protobuf:"bytes,2,opt,name=user_id" json:"user_id,omitempty"`
	// TODO(cesarghali): implement app_id filtering.
	// Only return the keys belonging to this app.
	AppId string `protobuf:"bytes,3,opt,name=app_id" json:"app_id,omitempty"`
	// TODO: implement key_hash filtering.
	// Only return SEH's that are signed by these keys.
	TrustedKeys []uint64 `protobuf:"fixed64,4,rep,name=trusted_keys" json:"trusted_keys,omitempty"`
}

func (m *GetEntryRequest) Reset()         { *m = GetEntryRequest{} }
func (m *GetEntryRequest) String() string { return proto.CompactTextString(m) }
func (*GetEntryRequest) ProtoMessage()    {}

// Get a list of historical values for a user.
type ListEntryHistoryRequest struct {
	// The user identifier.
	UserId string `protobuf:"bytes,1,opt,name=user_id" json:"user_id,omitempty"`
	// from_epoch is the starting epcoh.
	StartEpoch uint64 `protobuf:"varint,2,opt,name=start_epoch" json:"start_epoch,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListEntryHistoryRequest) Reset()         { *m = ListEntryHistoryRequest{} }
func (m *ListEntryHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*ListEntryHistoryRequest) ProtoMessage()    {}

// A paginated history of values for a user.
type ListEntryHistoryResponse struct {
	// The list of values this user_id has contained over time.
	Values []*GetEntryResponse `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
	// The next time to query for pagination.
	NextEpoch uint64 `protobuf:"varint,2,opt,name=next_epoch" json:"next_epoch,omitempty"`
}

func (m *ListEntryHistoryResponse) Reset()         { *m = ListEntryHistoryResponse{} }
func (m *ListEntryHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*ListEntryHistoryResponse) ProtoMessage()    {}

func (m *ListEntryHistoryResponse) GetValues() []*GetEntryResponse {
	if m != nil {
		return m.Values
	}
	return nil
}

// Update a user's profile.
type UpdateEntryRequest struct {
	// UserID specifies the id for the new account to be registered.
	UserId string `protobuf:"bytes,1,opt,name=user_id" json:"user_id,omitempty"`
	// SignedEntryUpdate authorizes the change to profile.
	SignedEntryUpdate *SignedEntryUpdate `protobuf:"bytes,2,opt,name=signed_entry_update" json:"signed_entry_update,omitempty"`
	// Profile is the serialized protobuf Profile.
	// Profile is private and must not be released to verifiers.
	Profile []byte `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	// CommitmentKey is 16 random bytes.
	CommitmentKey []byte `protobuf:"bytes,4,opt,name=commitment_key,proto3" json:"commitment_key,omitempty"`
	// TODO: Provide a way for clients to specify a quorum of signatures to wait
	// on before returning.
	NotUsed []uint64 `protobuf:"fixed64,5,rep,name=not_used" json:"not_used,omitempty"`
	// DkimProof is used to vouch for the validity of a new registration.
	// Used when OAuth is not used.
	DkimProof []byte `protobuf:"bytes,1001,opt,name=dkim_proof,proto3" json:"dkim_proof,omitempty"`
}

func (m *UpdateEntryRequest) Reset()         { *m = UpdateEntryRequest{} }
func (m *UpdateEntryRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateEntryRequest) ProtoMessage()    {}

func (m *UpdateEntryRequest) GetSignedEntryUpdate() *SignedEntryUpdate {
	if m != nil {
		return m.SignedEntryUpdate
	}
	return nil
}

// UpdateEntryResponse contains a proof once the update has been included in
// the Merkel Tree.
type UpdateEntryResponse struct {
	Proof *GetEntryResponse `protobuf:"bytes,1,opt,name=proof" json:"proof,omitempty"`
}

func (m *UpdateEntryResponse) Reset()         { *m = UpdateEntryResponse{} }
func (m *UpdateEntryResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateEntryResponse) ProtoMessage()    {}

func (m *UpdateEntryResponse) GetProof() *GetEntryResponse {
	if m != nil {
		return m.Proof
	}
	return nil
}

type ListSEHRequest struct {
	// from_epoch is the starting epcoh.
	StartEpoch uint64 `protobuf:"varint,1,opt,name=start_epoch" json:"start_epoch,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListSEHRequest) Reset()         { *m = ListSEHRequest{} }
func (m *ListSEHRequest) String() string { return proto.CompactTextString(m) }
func (*ListSEHRequest) ProtoMessage()    {}

type ListSEHResponse struct {
	Heads []*SignedEpochHead `protobuf:"bytes,1,rep,name=heads" json:"heads,omitempty"`
}

func (m *ListSEHResponse) Reset()         { *m = ListSEHResponse{} }
func (m *ListSEHResponse) String() string { return proto.CompactTextString(m) }
func (*ListSEHResponse) ProtoMessage()    {}

func (m *ListSEHResponse) GetHeads() []*SignedEpochHead {
	if m != nil {
		return m.Heads
	}
	return nil
}

type ListUpdateRequest struct {
	// start_commitment_timestamp is the starting commitment timestamp.
	StartCommitmentTimestamp uint64 `protobuf:"varint,1,opt,name=start_commitment_timestamp" json:"start_commitment_timestamp,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListUpdateRequest) Reset()         { *m = ListUpdateRequest{} }
func (m *ListUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*ListUpdateRequest) ProtoMessage()    {}

type ListUpdateResponse struct {
	// updates contains a serialized SignedEntryUpdate.
	Updates [][]byte `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates,omitempty"`
}

func (m *ListUpdateResponse) Reset()         { *m = ListUpdateResponse{} }
func (m *ListUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*ListUpdateResponse) ProtoMessage()    {}

type ListStepsRequest struct {
	// start_commitment_timestamp is the starting commitment timestamp.
	StartCommitmentTimestamp uint64 `protobuf:"varint,1,opt,name=start_commitment_timestamp" json:"start_commitment_timestamp,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListStepsRequest) Reset()         { *m = ListStepsRequest{} }
func (m *ListStepsRequest) String() string { return proto.CompactTextString(m) }
func (*ListStepsRequest) ProtoMessage()    {}

type ListStepsResponse struct {
	Steps []*Step `protobuf:"bytes,1,rep,name=steps" json:"steps,omitempty"`
}

func (m *ListStepsResponse) Reset()         { *m = ListStepsResponse{} }
func (m *ListStepsResponse) String() string { return proto.CompactTextString(m) }
func (*ListStepsResponse) ProtoMessage()    {}

func (m *ListStepsResponse) GetSteps() []*Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for E2EKeyService service

type E2EKeyServiceClient interface {
	// GetEntry returns a user's entry in the Merkle Tree. Entries contain
	// signed commitments to a profile, which is also returned.
	GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*GetEntryResponse, error)
	// ListEntryHistory returns a list of GetEntryRespons covering several epochs.
	ListEntryHistory(ctx context.Context, in *ListEntryHistoryRequest, opts ...grpc.CallOption) (*ListEntryHistoryResponse, error)
	// blocking or polling?
	// UpdateEntry submits a SignedEntryUpdate.  Returns empty until this update
	// has been included in an epoch.  Clients must retry until this function
	// returns a proof.
	UpdateEntry(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*UpdateEntryResponse, error)
	// List the Signed Epoch Heads, from epoch to epoch.
	ListSEH(ctx context.Context, in *ListSEHRequest, opts ...grpc.CallOption) (*ListSEHResponse, error)
	// List the EntryUpdates by update number.
	ListUpdate(ctx context.Context, in *ListUpdateRequest, opts ...grpc.CallOption) (*ListUpdateResponse, error)
	// ListSteps combines SEH and EntryUpdates into single list.
	ListSteps(ctx context.Context, in *ListStepsRequest, opts ...grpc.CallOption) (*ListStepsResponse, error)
}

type e2EKeyServiceClient struct {
	cc *grpc.ClientConn
}

func NewE2EKeyServiceClient(cc *grpc.ClientConn) E2EKeyServiceClient {
	return &e2EKeyServiceClient{cc}
}

func (c *e2EKeyServiceClient) GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*GetEntryResponse, error) {
	out := new(GetEntryResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/GetEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListEntryHistory(ctx context.Context, in *ListEntryHistoryRequest, opts ...grpc.CallOption) (*ListEntryHistoryResponse, error) {
	out := new(ListEntryHistoryResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListEntryHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) UpdateEntry(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*UpdateEntryResponse, error) {
	out := new(UpdateEntryResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/UpdateEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListSEH(ctx context.Context, in *ListSEHRequest, opts ...grpc.CallOption) (*ListSEHResponse, error) {
	out := new(ListSEHResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListSEH", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListUpdate(ctx context.Context, in *ListUpdateRequest, opts ...grpc.CallOption) (*ListUpdateResponse, error) {
	out := new(ListUpdateResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListSteps(ctx context.Context, in *ListStepsRequest, opts ...grpc.CallOption) (*ListStepsResponse, error) {
	out := new(ListStepsResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListSteps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKeyService service

type E2EKeyServiceServer interface {
	// GetEntry returns a user's entry in the Merkle Tree. Entries contain
	// signed commitments to a profile, which is also returned.
	GetEntry(context.Context, *GetEntryRequest) (*GetEntryResponse, error)
	// ListEntryHistory returns a list of GetEntryRespons covering several epochs.
	ListEntryHistory(context.Context, *ListEntryHistoryRequest) (*ListEntryHistoryResponse, error)
	// blocking or polling?
	// UpdateEntry submits a SignedEntryUpdate.  Returns empty until this update
	// has been included in an epoch.  Clients must retry until this function
	// returns a proof.
	UpdateEntry(context.Context, *UpdateEntryRequest) (*UpdateEntryResponse, error)
	// List the Signed Epoch Heads, from epoch to epoch.
	ListSEH(context.Context, *ListSEHRequest) (*ListSEHResponse, error)
	// List the EntryUpdates by update number.
	ListUpdate(context.Context, *ListUpdateRequest) (*ListUpdateResponse, error)
	// ListSteps combines SEH and EntryUpdates into single list.
	ListSteps(context.Context, *ListStepsRequest) (*ListStepsResponse, error)
}

func RegisterE2EKeyServiceServer(s *grpc.Server, srv E2EKeyServiceServer) {
	s.RegisterService(&_E2EKeyService_serviceDesc, srv)
}

func _E2EKeyService_GetEntry_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(GetEntryRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).GetEntry(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListEntryHistory_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ListEntryHistoryRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListEntryHistory(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_UpdateEntry_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UpdateEntryRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).UpdateEntry(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListSEH_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ListSEHRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListSEH(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListUpdate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ListUpdateRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListUpdate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListSteps_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ListStepsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListSteps(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _E2EKeyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.security.e2ekeys.v2.E2EKeyService",
	HandlerType: (*E2EKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEntry",
			Handler:    _E2EKeyService_GetEntry_Handler,
		},
		{
			MethodName: "ListEntryHistory",
			Handler:    _E2EKeyService_ListEntryHistory_Handler,
		},
		{
			MethodName: "UpdateEntry",
			Handler:    _E2EKeyService_UpdateEntry_Handler,
		},
		{
			MethodName: "ListSEH",
			Handler:    _E2EKeyService_ListSEH_Handler,
		},
		{
			MethodName: "ListUpdate",
			Handler:    _E2EKeyService_ListUpdate_Handler,
		},
		{
			MethodName: "ListSteps",
			Handler:    _E2EKeyService_ListSteps_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
