// Code generated by protoc-gen-go.
// source: proto/v2/e2ekeys.proto
// DO NOT EDIT!

/*
Package google_security_e2ekeys_v2 is a generated protocol buffer package.

It is generated from these files:
	proto/v2/e2ekeys.proto

It has these top-level messages:
	SignedEpochHead
	EpochHead
	GetEntryResponse
	Step
	SignedEntryUpdate
	Entry
	Profile
	PublicKey
	GetEntryRequest
	ListEntryHistoryRequest
	ListEntryHistoryResponse
	UpdateEntryRequest
	UpdateEntryResponse
	ListSEHRequest
	ListSEHResponse
	ListUpdateRequest
	ListUpdateResponse
	ListStepsRequest
	ListStepsResponse
*/
package google_security_e2ekeys_v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/google/e2e-key-server/proto/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// SignedEpochHead represents a signed state of the Merkel tree.
type SignedEpochHead struct {
	// Serialized EpochHead.
	EpochHead []byte `protobuf:"bytes,1,opt,name=epoch_head,proto3" json:"epoch_head,omitempty"`
	// Signature of head, using the signature type of the key.
	// keyed by the first 64 bits bytes of the hash of the key.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()                    { *m = SignedEpochHead{} }
func (m *SignedEpochHead) String() string            { return proto.CompactTextString(m) }
func (*SignedEpochHead) ProtoMessage()               {}
func (*SignedEpochHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// EpochHead is the head node of the Merkle Tree as well as additional metadata
// for the tree.
type EpochHead struct {
	// Realm is the domain...
	Realm string `protobuf:"bytes,1,opt,name=realm" json:"realm,omitempty"`
	// Epoch number
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch" json:"epoch,omitempty"`
	// Root is the value of the root node of the merkle tree.
	Root []byte `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// IssueTime is the time when this epoch was released. All epochs for the
	// same keyserver MUST have non-decreasing IssueTimes.
	IssueTime *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=issue_time" json:"issue_time,omitempty"`
	// Hash of previous SEH. 64 bytes of SHA3-SHAKE256.
	PreviousEpochHeadHash []byte `protobuf:"bytes,5,opt,name=previous_epoch_head_hash,proto3" json:"previous_epoch_head_hash,omitempty"`
}

func (m *EpochHead) Reset()                    { *m = EpochHead{} }
func (m *EpochHead) String() string            { return proto.CompactTextString(m) }
func (*EpochHead) ProtoMessage()               {}
func (*EpochHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EpochHead) GetIssueTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return nil
}

type GetEntryResponse struct {
	// UserId supports sending this as a complete proof to a third party.
	UserId string `protobuf:"bytes,1,opt,name=user_id" json:"user_id,omitempty"`
	// IndexProof is the proof for VUF(user_id).
	IndexProof []byte `protobuf:"bytes,2,opt,name=index_proof,proto3" json:"index_proof,omitempty"`
	// Index is the output of VUF on (user_id).
	// If index != entry.index,  but they share a common prefix of
	// len(merkle_tree_neighbors), this is a proof of absence for user_id.
	Index []byte `protobuf:"bytes,3,opt,name=index,proto3" json:"index,omitempty"`
	// The signed epoch head.  A server may choose to return multiple signatures
	// of the same head for the same epoch. A client MUST NOT consider the
	// presence of surplus or invalid epoch heads in this field an error.
	SignedEpochHeads []*SignedEpochHead `protobuf:"bytes,4,rep,name=signed_epoch_heads" json:"signed_epoch_heads,omitempty"`
	// MerkleTreeNeighbors is a list of all the adjacent nodes along the path
	// from the bottommost node to the head.
	MerkleTreeNeighbors [][]byte `protobuf:"bytes,5,rep,name=merkle_tree_neighbors,proto3" json:"merkle_tree_neighbors,omitempty"`
	// Entry contains the public portion of the user's data, and a comitment to
	// profile.
	Entry *Entry `protobuf:"bytes,6,opt,name=entry" json:"entry,omitempty"`
	// Profile contains the user's keys.
	Profile []byte `protobuf:"bytes,7,opt,name=profile,proto3" json:"profile,omitempty"`
	// CommitmentKey is 16 random bytes.
	CommitmentKey []byte `protobuf:"bytes,8,opt,name=commitment_key,proto3" json:"commitment_key,omitempty"`
}

func (m *GetEntryResponse) Reset()                    { *m = GetEntryResponse{} }
func (m *GetEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*GetEntryResponse) ProtoMessage()               {}
func (*GetEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetEntryResponse) GetSignedEpochHeads() []*SignedEpochHead {
	if m != nil {
		return m.SignedEpochHeads
	}
	return nil
}

func (m *GetEntryResponse) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

// Step is a combined, ordered list of SignedEntryUpdates and SignedEpochHeads
// which are made available to verifiers.
type Step struct {
	// Types that are valid to be assigned to Type:
	//	*Step_EntryChanged
	//	*Step_SignedEpochHead
	Type isStep_Type `protobuf_oneof:"type"`
	// epoch of this udpate.
	Epoch uint64 `protobuf:"varint,3,opt,name=epoch" json:"epoch,omitempty"`
	// commitment_timestamp is the ordered commitment_timestamp of this step.
	CommitmentTimestamp uint64 `protobuf:"varint,4,opt,name=commitment_timestamp" json:"commitment_timestamp,omitempty"`
}

func (m *Step) Reset()                    { *m = Step{} }
func (m *Step) String() string            { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()               {}
func (*Step) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isStep_Type interface {
	isStep_Type()
}

type Step_EntryChanged struct {
	EntryChanged []byte `protobuf:"bytes,1,opt,name=entry_changed,proto3,oneof"`
}
type Step_SignedEpochHead struct {
	SignedEpochHead *SignedEpochHead `protobuf:"bytes,2,opt,name=signed_epoch_head,oneof"`
}

func (*Step_EntryChanged) isStep_Type()    {}
func (*Step_SignedEpochHead) isStep_Type() {}

func (m *Step) GetType() isStep_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Step) GetEntryChanged() []byte {
	if x, ok := m.GetType().(*Step_EntryChanged); ok {
		return x.EntryChanged
	}
	return nil
}

func (m *Step) GetSignedEpochHead() *SignedEpochHead {
	if x, ok := m.GetType().(*Step_SignedEpochHead); ok {
		return x.SignedEpochHead
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Step) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Step_OneofMarshaler, _Step_OneofUnmarshaler, _Step_OneofSizer, []interface{}{
		(*Step_EntryChanged)(nil),
		(*Step_SignedEpochHead)(nil),
	}
}

func _Step_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Step)
	// type
	switch x := m.Type.(type) {
	case *Step_EntryChanged:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.EntryChanged)
	case *Step_SignedEpochHead:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SignedEpochHead); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Step.Type has unexpected type %T", x)
	}
	return nil
}

func _Step_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Step)
	switch tag {
	case 1: // type.entry_changed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &Step_EntryChanged{x}
		return true, err
	case 2: // type.signed_epoch_head
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SignedEpochHead)
		err := b.DecodeMessage(msg)
		m.Type = &Step_SignedEpochHead{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Step_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Step)
	// type
	switch x := m.Type.(type) {
	case *Step_EntryChanged:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.EntryChanged)))
		n += len(x.EntryChanged)
	case *Step_SignedEpochHead:
		s := proto.Size(x.SignedEpochHead)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SignedEntryUpdate is what users provide to update their profiles.
// A serialized SignedEntryUpdate is used as the leaf value in the MerkleTree.
type SignedEntryUpdate struct {
	// NewEntry is the serialized protobuf Entry.
	NewEntry []byte `protobuf:"bytes,1,opt,name=new_entry,proto3" json:"new_entry,omitempty"`
	// Signature of entry, by the entry_key inside entry AND the old key from the
	// previous epoch. The first proves ownership of new epoch key, and the
	// second proves the the correct owner is making this change.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEntryUpdate) Reset()                    { *m = SignedEntryUpdate{} }
func (m *SignedEntryUpdate) String() string            { return proto.CompactTextString(m) }
func (*SignedEntryUpdate) ProtoMessage()               {}
func (*SignedEntryUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SignedEntryUpdate) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.
type Entry struct {
	// Index is the location in the merkle tree for this entry.
	// If signing keys are not unique per user, we need to tie updates to a
	// particular profile.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// UpdateCount prevents replaying old signed EntryUpdates.
	// not nessesarilly incremented by only one each update.
	UpdateCount uint64 `protobuf:"varint,2,opt,name=update_count" json:"update_count,omitempty"`
	// EntryKey allows verifiers to validate updates to Entry.
	EntryKey []*PublicKey `protobuf:"bytes,3,rep,name=entry_key" json:"entry_key,omitempty"`
	// profile_commitment is a cryptographic commitment to the Profile of the form
	// HMAC(profile_commitment_key, serialized_profile)
	ProfileCommitment []byte `protobuf:"bytes,4,opt,name=profile_commitment,proto3" json:"profile_commitment,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Entry) GetEntryKey() []*PublicKey {
	if m != nil {
		return m.EntryKey
	}
	return nil
}

// Profile contains data hidden behind the crypto comitment.
type Profile struct {
	// Keys is a map of appIds to keys.
	Keys map[string][]byte `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (m *Profile) String() string            { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Profile) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// PublicKey defines a key this domain uses to sign EpochHeads with.
type PublicKey struct {
	// KeyFormats from Keyczar.
	//
	// Types that are valid to be assigned to KeyType:
	//	*PublicKey_Ed25519
	//	*PublicKey_RsaVerifyingSha256_2048
	//	*PublicKey_EcdsaVerifyingP256
	KeyType isPublicKey_KeyType `protobuf_oneof:"key_type"`
}

func (m *PublicKey) Reset()                    { *m = PublicKey{} }
func (m *PublicKey) String() string            { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()               {}
func (*PublicKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isPublicKey_KeyType interface {
	isPublicKey_KeyType()
}

type PublicKey_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,1,opt,name=ed25519,proto3,oneof"`
}
type PublicKey_RsaVerifyingSha256_2048 struct {
	RsaVerifyingSha256_2048 []byte `protobuf:"bytes,2,opt,name=rsa_verifying_sha256_2048,proto3,oneof"`
}
type PublicKey_EcdsaVerifyingP256 struct {
	EcdsaVerifyingP256 []byte `protobuf:"bytes,3,opt,name=ecdsa_verifying_p256,proto3,oneof"`
}

func (*PublicKey_Ed25519) isPublicKey_KeyType()                 {}
func (*PublicKey_RsaVerifyingSha256_2048) isPublicKey_KeyType() {}
func (*PublicKey_EcdsaVerifyingP256) isPublicKey_KeyType()      {}

func (m *PublicKey) GetKeyType() isPublicKey_KeyType {
	if m != nil {
		return m.KeyType
	}
	return nil
}

func (m *PublicKey) GetEd25519() []byte {
	if x, ok := m.GetKeyType().(*PublicKey_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *PublicKey) GetRsaVerifyingSha256_2048() []byte {
	if x, ok := m.GetKeyType().(*PublicKey_RsaVerifyingSha256_2048); ok {
		return x.RsaVerifyingSha256_2048
	}
	return nil
}

func (m *PublicKey) GetEcdsaVerifyingP256() []byte {
	if x, ok := m.GetKeyType().(*PublicKey_EcdsaVerifyingP256); ok {
		return x.EcdsaVerifyingP256
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PublicKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PublicKey_OneofMarshaler, _PublicKey_OneofUnmarshaler, _PublicKey_OneofSizer, []interface{}{
		(*PublicKey_Ed25519)(nil),
		(*PublicKey_RsaVerifyingSha256_2048)(nil),
		(*PublicKey_EcdsaVerifyingP256)(nil),
	}
}

func _PublicKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PublicKey)
	// key_type
	switch x := m.KeyType.(type) {
	case *PublicKey_Ed25519:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Ed25519)
	case *PublicKey_RsaVerifyingSha256_2048:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.RsaVerifyingSha256_2048)
	case *PublicKey_EcdsaVerifyingP256:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.EcdsaVerifyingP256)
	case nil:
	default:
		return fmt.Errorf("PublicKey.KeyType has unexpected type %T", x)
	}
	return nil
}

func _PublicKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PublicKey)
	switch tag {
	case 1: // key_type.ed25519
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyType = &PublicKey_Ed25519{x}
		return true, err
	case 2: // key_type.rsa_verifying_sha256_2048
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyType = &PublicKey_RsaVerifyingSha256_2048{x}
		return true, err
	case 3: // key_type.ecdsa_verifying_p256
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.KeyType = &PublicKey_EcdsaVerifyingP256{x}
		return true, err
	default:
		return false, nil
	}
}

func _PublicKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PublicKey)
	// key_type
	switch x := m.KeyType.(type) {
	case *PublicKey_Ed25519:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Ed25519)))
		n += len(x.Ed25519)
	case *PublicKey_RsaVerifyingSha256_2048:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.RsaVerifyingSha256_2048)))
		n += len(x.RsaVerifyingSha256_2048)
	case *PublicKey_EcdsaVerifyingP256:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.EcdsaVerifyingP256)))
		n += len(x.EcdsaVerifyingP256)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Get request for a user object.
type GetEntryRequest struct {
	// Absence of the time field indicates a request for the current value.
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch" json:"epoch,omitempty"`
	// User identifier. Most commonly an email address.
	UserId string `protobuf:"bytes,2,opt,name=user_id" json:"user_id,omitempty"`
	// TODO(cesarghali): implement app_id filtering.
	// Only return the keys belonging to this app.
	AppId string `protobuf:"bytes,3,opt,name=app_id" json:"app_id,omitempty"`
	// TODO: implement key_hash filtering.
	// Only return SEH's that are signed by these keys.
	TrustedKeys []uint64 `protobuf:"fixed64,4,rep,name=trusted_keys" json:"trusted_keys,omitempty"`
}

func (m *GetEntryRequest) Reset()                    { *m = GetEntryRequest{} }
func (m *GetEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEntryRequest) ProtoMessage()               {}
func (*GetEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// Get a list of historical values for a user.
type ListEntryHistoryRequest struct {
	// The user identifier.
	UserId string `protobuf:"bytes,1,opt,name=user_id" json:"user_id,omitempty"`
	// from_epoch is the starting epcoh.
	StartEpoch uint64 `protobuf:"varint,2,opt,name=start_epoch" json:"start_epoch,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListEntryHistoryRequest) Reset()                    { *m = ListEntryHistoryRequest{} }
func (m *ListEntryHistoryRequest) String() string            { return proto.CompactTextString(m) }
func (*ListEntryHistoryRequest) ProtoMessage()               {}
func (*ListEntryHistoryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// A paginated history of values for a user.
type ListEntryHistoryResponse struct {
	// The list of values this user_id has contained over time.
	Values []*GetEntryResponse `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
	// The next time to query for pagination.
	NextEpoch uint64 `protobuf:"varint,2,opt,name=next_epoch" json:"next_epoch,omitempty"`
}

func (m *ListEntryHistoryResponse) Reset()                    { *m = ListEntryHistoryResponse{} }
func (m *ListEntryHistoryResponse) String() string            { return proto.CompactTextString(m) }
func (*ListEntryHistoryResponse) ProtoMessage()               {}
func (*ListEntryHistoryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListEntryHistoryResponse) GetValues() []*GetEntryResponse {
	if m != nil {
		return m.Values
	}
	return nil
}

// Update a user's profile.
type UpdateEntryRequest struct {
	// UserID specifies the id for the new account to be registered.
	UserId string `protobuf:"bytes,1,opt,name=user_id" json:"user_id,omitempty"`
	// SignedEntryUpdate authorizes the change to profile.
	SignedEntryUpdate *SignedEntryUpdate `protobuf:"bytes,2,opt,name=signed_entry_update" json:"signed_entry_update,omitempty"`
	// Profile is the serialized protobuf Profile.
	// Profile is private and must not be released to verifiers.
	Profile []byte `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	// CommitmentKey is 16 random bytes.
	CommitmentKey []byte `protobuf:"bytes,4,opt,name=commitment_key,proto3" json:"commitment_key,omitempty"`
	// TODO: Provide a way for clients to specify a quorum of signatures to wait
	// on before returning.
	NotUsed []uint64 `protobuf:"fixed64,5,rep,name=not_used" json:"not_used,omitempty"`
	// DkimProof is used to vouch for the validity of a new registration.
	// Used when OAuth is not used.
	DkimProof []byte `protobuf:"bytes,1001,opt,name=dkim_proof,proto3" json:"dkim_proof,omitempty"`
}

func (m *UpdateEntryRequest) Reset()                    { *m = UpdateEntryRequest{} }
func (m *UpdateEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateEntryRequest) ProtoMessage()               {}
func (*UpdateEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UpdateEntryRequest) GetSignedEntryUpdate() *SignedEntryUpdate {
	if m != nil {
		return m.SignedEntryUpdate
	}
	return nil
}

// UpdateEntryResponse contains a proof once the update has been included in
// the Merkel Tree.
type UpdateEntryResponse struct {
	Proof *GetEntryResponse `protobuf:"bytes,1,opt,name=proof" json:"proof,omitempty"`
}

func (m *UpdateEntryResponse) Reset()                    { *m = UpdateEntryResponse{} }
func (m *UpdateEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateEntryResponse) ProtoMessage()               {}
func (*UpdateEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UpdateEntryResponse) GetProof() *GetEntryResponse {
	if m != nil {
		return m.Proof
	}
	return nil
}

type ListSEHRequest struct {
	// from_epoch is the starting epcoh.
	StartEpoch uint64 `protobuf:"varint,1,opt,name=start_epoch" json:"start_epoch,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListSEHRequest) Reset()                    { *m = ListSEHRequest{} }
func (m *ListSEHRequest) String() string            { return proto.CompactTextString(m) }
func (*ListSEHRequest) ProtoMessage()               {}
func (*ListSEHRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type ListSEHResponse struct {
	Heads []*SignedEpochHead `protobuf:"bytes,1,rep,name=heads" json:"heads,omitempty"`
}

func (m *ListSEHResponse) Reset()                    { *m = ListSEHResponse{} }
func (m *ListSEHResponse) String() string            { return proto.CompactTextString(m) }
func (*ListSEHResponse) ProtoMessage()               {}
func (*ListSEHResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ListSEHResponse) GetHeads() []*SignedEpochHead {
	if m != nil {
		return m.Heads
	}
	return nil
}

type ListUpdateRequest struct {
	// start_commitment_timestamp is the starting commitment timestamp.
	StartCommitmentTimestamp uint64 `protobuf:"varint,1,opt,name=start_commitment_timestamp" json:"start_commitment_timestamp,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListUpdateRequest) Reset()                    { *m = ListUpdateRequest{} }
func (m *ListUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*ListUpdateRequest) ProtoMessage()               {}
func (*ListUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type ListUpdateResponse struct {
	// updates contains a serialized SignedEntryUpdate.
	Updates [][]byte `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates,omitempty"`
}

func (m *ListUpdateResponse) Reset()                    { *m = ListUpdateResponse{} }
func (m *ListUpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*ListUpdateResponse) ProtoMessage()               {}
func (*ListUpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type ListStepsRequest struct {
	// start_commitment_timestamp is the starting commitment timestamp.
	StartCommitmentTimestamp uint64 `protobuf:"varint,1,opt,name=start_commitment_timestamp" json:"start_commitment_timestamp,omitempty"`
	// The maximum number of entries to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size" json:"page_size,omitempty"`
}

func (m *ListStepsRequest) Reset()                    { *m = ListStepsRequest{} }
func (m *ListStepsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListStepsRequest) ProtoMessage()               {}
func (*ListStepsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type ListStepsResponse struct {
	Steps []*Step `protobuf:"bytes,1,rep,name=steps" json:"steps,omitempty"`
}

func (m *ListStepsResponse) Reset()                    { *m = ListStepsResponse{} }
func (m *ListStepsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListStepsResponse) ProtoMessage()               {}
func (*ListStepsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ListStepsResponse) GetSteps() []*Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func init() {
	proto.RegisterType((*SignedEpochHead)(nil), "google.security.e2ekeys.v2.SignedEpochHead")
	proto.RegisterType((*EpochHead)(nil), "google.security.e2ekeys.v2.EpochHead")
	proto.RegisterType((*GetEntryResponse)(nil), "google.security.e2ekeys.v2.GetEntryResponse")
	proto.RegisterType((*Step)(nil), "google.security.e2ekeys.v2.Step")
	proto.RegisterType((*SignedEntryUpdate)(nil), "google.security.e2ekeys.v2.SignedEntryUpdate")
	proto.RegisterType((*Entry)(nil), "google.security.e2ekeys.v2.Entry")
	proto.RegisterType((*Profile)(nil), "google.security.e2ekeys.v2.Profile")
	proto.RegisterType((*PublicKey)(nil), "google.security.e2ekeys.v2.PublicKey")
	proto.RegisterType((*GetEntryRequest)(nil), "google.security.e2ekeys.v2.GetEntryRequest")
	proto.RegisterType((*ListEntryHistoryRequest)(nil), "google.security.e2ekeys.v2.ListEntryHistoryRequest")
	proto.RegisterType((*ListEntryHistoryResponse)(nil), "google.security.e2ekeys.v2.ListEntryHistoryResponse")
	proto.RegisterType((*UpdateEntryRequest)(nil), "google.security.e2ekeys.v2.UpdateEntryRequest")
	proto.RegisterType((*UpdateEntryResponse)(nil), "google.security.e2ekeys.v2.UpdateEntryResponse")
	proto.RegisterType((*ListSEHRequest)(nil), "google.security.e2ekeys.v2.ListSEHRequest")
	proto.RegisterType((*ListSEHResponse)(nil), "google.security.e2ekeys.v2.ListSEHResponse")
	proto.RegisterType((*ListUpdateRequest)(nil), "google.security.e2ekeys.v2.ListUpdateRequest")
	proto.RegisterType((*ListUpdateResponse)(nil), "google.security.e2ekeys.v2.ListUpdateResponse")
	proto.RegisterType((*ListStepsRequest)(nil), "google.security.e2ekeys.v2.ListStepsRequest")
	proto.RegisterType((*ListStepsResponse)(nil), "google.security.e2ekeys.v2.ListStepsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for E2EKeyService service

type E2EKeyServiceClient interface {
	// GetEntry returns a user's entry in the Merkle Tree. Entries contain
	// signed commitments to a profile, which is also returned.
	GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*GetEntryResponse, error)
	// ListEntryHistory returns a list of GetEntryRespons covering several epochs.
	ListEntryHistory(ctx context.Context, in *ListEntryHistoryRequest, opts ...grpc.CallOption) (*ListEntryHistoryResponse, error)
	// blocking or polling?
	// UpdateEntry submits a SignedEntryUpdate.  Returns empty until this update
	// has been included in an epoch.  Clients must retry until this function
	// returns a proof.
	UpdateEntry(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*UpdateEntryResponse, error)
	// List the Signed Epoch Heads, from epoch to epoch.
	ListSEH(ctx context.Context, in *ListSEHRequest, opts ...grpc.CallOption) (*ListSEHResponse, error)
	// List the EntryUpdates by update number.
	ListUpdate(ctx context.Context, in *ListUpdateRequest, opts ...grpc.CallOption) (*ListUpdateResponse, error)
	// ListSteps combines SEH and EntryUpdates into single list.
	ListSteps(ctx context.Context, in *ListStepsRequest, opts ...grpc.CallOption) (*ListStepsResponse, error)
}

type e2EKeyServiceClient struct {
	cc *grpc.ClientConn
}

func NewE2EKeyServiceClient(cc *grpc.ClientConn) E2EKeyServiceClient {
	return &e2EKeyServiceClient{cc}
}

func (c *e2EKeyServiceClient) GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*GetEntryResponse, error) {
	out := new(GetEntryResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/GetEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListEntryHistory(ctx context.Context, in *ListEntryHistoryRequest, opts ...grpc.CallOption) (*ListEntryHistoryResponse, error) {
	out := new(ListEntryHistoryResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListEntryHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) UpdateEntry(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*UpdateEntryResponse, error) {
	out := new(UpdateEntryResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/UpdateEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListSEH(ctx context.Context, in *ListSEHRequest, opts ...grpc.CallOption) (*ListSEHResponse, error) {
	out := new(ListSEHResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListSEH", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListUpdate(ctx context.Context, in *ListUpdateRequest, opts ...grpc.CallOption) (*ListUpdateResponse, error) {
	out := new(ListUpdateResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKeyServiceClient) ListSteps(ctx context.Context, in *ListStepsRequest, opts ...grpc.CallOption) (*ListStepsResponse, error) {
	out := new(ListStepsResponse)
	err := grpc.Invoke(ctx, "/google.security.e2ekeys.v2.E2EKeyService/ListSteps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKeyService service

type E2EKeyServiceServer interface {
	// GetEntry returns a user's entry in the Merkle Tree. Entries contain
	// signed commitments to a profile, which is also returned.
	GetEntry(context.Context, *GetEntryRequest) (*GetEntryResponse, error)
	// ListEntryHistory returns a list of GetEntryRespons covering several epochs.
	ListEntryHistory(context.Context, *ListEntryHistoryRequest) (*ListEntryHistoryResponse, error)
	// blocking or polling?
	// UpdateEntry submits a SignedEntryUpdate.  Returns empty until this update
	// has been included in an epoch.  Clients must retry until this function
	// returns a proof.
	UpdateEntry(context.Context, *UpdateEntryRequest) (*UpdateEntryResponse, error)
	// List the Signed Epoch Heads, from epoch to epoch.
	ListSEH(context.Context, *ListSEHRequest) (*ListSEHResponse, error)
	// List the EntryUpdates by update number.
	ListUpdate(context.Context, *ListUpdateRequest) (*ListUpdateResponse, error)
	// ListSteps combines SEH and EntryUpdates into single list.
	ListSteps(context.Context, *ListStepsRequest) (*ListStepsResponse, error)
}

func RegisterE2EKeyServiceServer(s *grpc.Server, srv E2EKeyServiceServer) {
	s.RegisterService(&_E2EKeyService_serviceDesc, srv)
}

func _E2EKeyService_GetEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).GetEntry(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListEntryHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListEntryHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListEntryHistory(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_UpdateEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpdateEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).UpdateEntry(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListSEH_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListSEHRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListSEH(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListUpdate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKeyService_ListSteps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListStepsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKeyServiceServer).ListSteps(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _E2EKeyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.security.e2ekeys.v2.E2EKeyService",
	HandlerType: (*E2EKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEntry",
			Handler:    _E2EKeyService_GetEntry_Handler,
		},
		{
			MethodName: "ListEntryHistory",
			Handler:    _E2EKeyService_ListEntryHistory_Handler,
		},
		{
			MethodName: "UpdateEntry",
			Handler:    _E2EKeyService_UpdateEntry_Handler,
		},
		{
			MethodName: "ListSEH",
			Handler:    _E2EKeyService_ListSEH_Handler,
		},
		{
			MethodName: "ListUpdate",
			Handler:    _E2EKeyService_ListUpdate_Handler,
		},
		{
			MethodName: "ListSteps",
			Handler:    _E2EKeyService_ListSteps_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 1066 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xee, 0xc6, 0x3f, 0x89, 0x4f, 0x9c, 0x1f, 0x4f, 0x42, 0x6b, 0x56, 0x80, 0xc2, 0xa2, 0x4a,
	0x15, 0xa9, 0xd7, 0xed, 0xb6, 0x41, 0xa1, 0x29, 0x37, 0x15, 0x56, 0x4d, 0x01, 0x51, 0x1a, 0x10,
	0x97, 0xab, 0xb5, 0x3d, 0xb1, 0x57, 0xb1, 0x77, 0x97, 0x9d, 0x5d, 0x53, 0x23, 0x71, 0xc3, 0x1d,
	0x3c, 0x04, 0xe2, 0x16, 0x89, 0x97, 0xe0, 0x71, 0x78, 0x0b, 0xce, 0x9c, 0x19, 0x7b, 0xd7, 0x75,
	0xe2, 0xd8, 0xa2, 0x77, 0x99, 0xd9, 0x33, 0xdf, 0xf9, 0xce, 0x77, 0xbe, 0x73, 0x62, 0xb8, 0x1d,
	0xc5, 0x61, 0x12, 0x36, 0xc7, 0x4e, 0x93, 0x3b, 0xfc, 0x92, 0x4f, 0x84, 0x4d, 0x17, 0xcc, 0xec,
	0x87, 0x61, 0x7f, 0xc8, 0x6d, 0xc1, 0xbb, 0x69, 0xec, 0x27, 0x13, 0x7b, 0xfa, 0x79, 0xec, 0x98,
	0x4f, 0xfb, 0x7e, 0x32, 0x48, 0x3b, 0x76, 0x37, 0x1c, 0x35, 0x55, 0x98, 0x7c, 0xdc, 0xc0, 0xcf,
	0x0d, 0xc1, 0xe3, 0x31, 0x8f, 0x9b, 0x0a, 0x34, 0x99, 0x44, 0x5c, 0x34, 0x13, 0x7f, 0xc4, 0x45,
	0xe2, 0x8d, 0x22, 0x85, 0x6c, 0xfd, 0x65, 0xc0, 0xde, 0xb9, 0xdf, 0x0f, 0x78, 0xaf, 0x15, 0x85,
	0xdd, 0x41, 0x9b, 0x7b, 0x3d, 0xc6, 0x00, 0xb8, 0x3c, 0xb8, 0x03, 0x3c, 0xd5, 0x8d, 0x23, 0xe3,
	0x5e, 0x95, 0x7d, 0x03, 0x20, 0x30, 0xcc, 0x4b, 0xd2, 0x98, 0x8b, 0xfa, 0xc6, 0x51, 0xe1, 0xde,
	0xb6, 0x73, 0x66, 0x5f, 0x4f, 0xcb, 0x7e, 0x03, 0x94, 0xce, 0xea, 0x75, 0x2b, 0x48, 0xe2, 0x89,
	0xf9, 0x50, 0xe5, 0xcd, 0x5d, 0xb1, 0x6d, 0x28, 0xe0, 0x6b, 0x4a, 0x58, 0x66, 0x3b, 0x50, 0x1a,
	0x7b, 0xc3, 0x94, 0x63, 0x2e, 0xcc, 0xff, 0x64, 0xe3, 0xd4, 0xb0, 0x7e, 0x33, 0xa0, 0x92, 0xb1,
	0xc4, 0x80, 0x98, 0x7b, 0xc3, 0x11, 0xc5, 0x57, 0xe4, 0x91, 0x48, 0x53, 0x7c, 0x91, 0x55, 0xa1,
	0x18, 0x87, 0x61, 0x52, 0x2f, 0x10, 0x7b, 0x1b, 0xc0, 0x17, 0x22, 0xe5, 0xae, 0x2c, 0xbf, 0x5e,
	0xc4, 0xbb, 0x6d, 0xc7, 0x9c, 0xb2, 0x27, 0x21, 0x3a, 0xe9, 0x85, 0xfd, 0xdd, 0x54, 0x1b, 0x76,
	0x04, 0xf5, 0x28, 0xe6, 0x63, 0x3f, 0x4c, 0x85, 0x9b, 0x49, 0xe1, 0x0e, 0x3c, 0x31, 0xa8, 0x97,
	0x24, 0xa2, 0xf5, 0xfb, 0x06, 0xec, 0x3f, 0xe7, 0x09, 0x11, 0x7f, 0xc5, 0x45, 0x14, 0x06, 0x82,
	0xb3, 0x3d, 0xd8, 0x4c, 0x51, 0x73, 0xd7, 0xef, 0x69, 0x52, 0x07, 0xb0, 0xed, 0x07, 0x3d, 0xfe,
	0xda, 0xc5, 0x1c, 0xe1, 0x85, 0x2a, 0x45, 0x32, 0xa5, 0x4b, 0xcd, 0xed, 0x39, 0x30, 0x41, 0x5a,
	0xe5, 0x32, 0x09, 0xe4, 0x28, 0x15, 0x3e, 0x5e, 0x43, 0x61, 0xf6, 0x3e, 0xbc, 0x33, 0xe2, 0xf1,
	0xe5, 0x10, 0xab, 0x8c, 0x39, 0x77, 0x03, 0xee, 0xf7, 0x07, 0x9d, 0x30, 0x16, 0xc8, 0xb8, 0x80,
	0x79, 0x1e, 0xa0, 0x40, 0x92, 0x6d, 0xbd, 0x4c, 0xe5, 0x7f, 0xb8, 0x0c, 0x5a, 0xf5, 0x03, 0xcb,
	0x41, 0xde, 0x17, 0xfe, 0x90, 0xd7, 0x37, 0x89, 0xea, 0x6d, 0xd8, 0x45, 0x97, 0x8d, 0xfc, 0x64,
	0x84, 0x48, 0xae, 0xec, 0xd5, 0x16, 0x89, 0xf1, 0x87, 0x01, 0xc5, 0xf3, 0x84, 0x47, 0xec, 0x0e,
	0xec, 0x50, 0x0e, 0xb7, 0x3b, 0xf0, 0x82, 0x3e, 0xd7, 0xe6, 0x69, 0xdf, 0x62, 0x6d, 0xa8, 0x2d,
	0x14, 0x49, 0x72, 0xac, 0x57, 0x23, 0x22, 0xcd, 0xfa, 0x5c, 0xa0, 0x3e, 0xbf, 0x07, 0x87, 0x39,
	0x4a, 0x33, 0x77, 0x53, 0x8f, 0x8b, 0xcf, 0xca, 0x50, 0x94, 0xb6, 0xb7, 0xfe, 0x36, 0xa0, 0xa6,
	0xa1, 0x24, 0xbd, 0xef, 0xa3, 0x9e, 0x97, 0x70, 0x56, 0x83, 0x4a, 0xc0, 0x7f, 0x72, 0x95, 0x2a,
	0xca, 0xe6, 0xdf, 0x5e, 0x61, 0xf3, 0xcf, 0x56, 0x20, 0x98, 0xa1, 0xbe, 0x0d, 0xa3, 0xff, 0x6a,
	0x40, 0x49, 0x45, 0xce, 0xbc, 0xa2, 0xe8, 0x1d, 0x42, 0x35, 0xa5, 0x2c, 0x6e, 0x37, 0x4c, 0x83,
	0x44, 0x7b, 0xfd, 0x14, 0x2a, 0x4a, 0x75, 0x09, 0x5a, 0x20, 0xce, 0x77, 0x97, 0x71, 0x7e, 0x99,
	0x76, 0x86, 0x7e, 0xf7, 0x4b, 0x3e, 0x61, 0x26, 0x30, 0xdd, 0x61, 0x37, 0x53, 0x91, 0xb4, 0xab,
	0x5a, 0x02, 0x36, 0x5f, 0xaa, 0x6f, 0xec, 0x0c, 0x8a, 0xf2, 0x2d, 0x92, 0x90, 0xd8, 0x8d, 0xa5,
	0xd8, 0xea, 0x89, 0x8d, 0xe8, 0xba, 0xfe, 0x63, 0xa8, 0xcc, 0x0e, 0xf9, 0xca, 0x2b, 0x57, 0x55,
	0x1e, 0x42, 0x25, 0x63, 0x57, 0x83, 0x4d, 0xde, 0x73, 0x4e, 0x4e, 0x1e, 0x7e, 0x3a, 0xf3, 0xd1,
	0x47, 0xf0, 0x6e, 0x2c, 0x3c, 0x17, 0xb7, 0x9a, 0x7f, 0x31, 0xf1, 0x83, 0xbe, 0x2b, 0x06, 0x9e,
	0x73, 0xf2, 0x89, 0xeb, 0x3c, 0x78, 0x7c, 0xaa, 0x60, 0x30, 0xe8, 0x03, 0x38, 0xe4, 0xdd, 0xde,
	0x5c, 0x58, 0x84, 0x41, 0x6a, 0xde, 0xda, 0xb7, 0x9e, 0x01, 0x6c, 0x21, 0x09, 0x97, 0x9c, 0xf1,
	0x03, 0xec, 0x65, 0x63, 0xfc, 0x63, 0x8a, 0xee, 0xc9, 0x1c, 0x66, 0x90, 0xba, 0xb9, 0xa1, 0xde,
	0x20, 0xda, 0xbb, 0x50, 0xf6, 0xa2, 0x48, 0x9e, 0x0b, 0x74, 0xc6, 0xa6, 0x24, 0x71, 0x2a, 0x12,
	0x34, 0x37, 0xa9, 0x24, 0x47, 0xb7, 0x6c, 0xbd, 0x82, 0x3b, 0x5f, 0xf9, 0x42, 0x21, 0xb7, 0xf1,
	0x8f, 0x30, 0x4b, 0x70, 0xd5, 0x9a, 0x40, 0xd7, 0xc6, 0x89, 0x9b, 0xdf, 0x60, 0xe8, 0xce, 0xc8,
	0xeb, 0x73, 0x57, 0xf8, 0x3f, 0x73, 0xca, 0x54, 0xb2, 0x86, 0x50, 0x5f, 0xc4, 0xd4, 0xbb, 0xe7,
	0x29, 0x94, 0x49, 0xcc, 0x69, 0x97, 0xee, 0x2f, 0xeb, 0xd2, 0xc2, 0xe6, 0xc2, 0x95, 0x1f, 0xf0,
	0xd7, 0x73, 0x04, 0xac, 0x7f, 0x0c, 0x60, 0xca, 0xd3, 0x73, 0xf2, 0x2c, 0xb0, 0x7f, 0x01, 0x07,
	0xd3, 0xd9, 0x26, 0x17, 0x2a, 0x87, 0xea, 0xe9, 0x6e, 0xac, 0x35, 0x3c, 0xf9, 0x95, 0x53, 0xb8,
	0x66, 0xe5, 0x90, 0x3b, 0xd9, 0x3e, 0x6c, 0x05, 0x61, 0xe2, 0x22, 0x93, 0x1e, 0xed, 0xb7, 0x32,
	0x8a, 0x08, 0xbd, 0x4b, 0x7f, 0xa4, 0x57, 0xed, 0xbf, 0xb4, 0xb1, 0xb0, 0x0b, 0x07, 0x73, 0x25,
	0xe8, 0x72, 0xcf, 0xa0, 0xa4, 0xc2, 0x0c, 0x22, 0xb9, 0x96, 0x56, 0xd6, 0x29, 0xec, 0xca, 0x2e,
	0x9c, 0xb7, 0xda, 0x53, 0x49, 0xde, 0xe8, 0x9f, 0xb1, 0xd8, 0xbf, 0x0d, 0xea, 0xdf, 0xd7, 0xb0,
	0x37, 0x7b, 0xa9, 0x99, 0x3c, 0x81, 0x92, 0x5a, 0xf8, 0xc6, 0xda, 0x0b, 0xdf, 0x7a, 0x01, 0x35,
	0x09, 0xa7, 0x0a, 0x9c, 0x72, 0xb1, 0xc0, 0x54, 0x5c, 0xae, 0x5c, 0x8b, 0xd7, 0x52, 0xbb, 0x0b,
	0x2c, 0x8f, 0x95, 0xfb, 0x87, 0x46, 0x37, 0x8a, 0x5f, 0xd5, 0xfa, 0x02, 0xf6, 0xa9, 0x02, 0x5c,
	0xf6, 0xe2, 0x7f, 0x66, 0xfc, 0x5c, 0xb1, 0xd7, 0x50, 0x3a, 0x61, 0x13, 0x4a, 0x42, 0x5e, 0x68,
	0x39, 0x8e, 0x96, 0xca, 0x81, 0x81, 0xce, 0x9f, 0x25, 0xd8, 0x69, 0x39, 0x2d, 0x5c, 0x17, 0xe7,
	0xf8, 0x63, 0xc7, 0xef, 0x72, 0xc6, 0x61, 0x6b, 0xda, 0x32, 0x76, 0xbc, 0x5a, 0x63, 0xa9, 0x0e,
	0x73, 0xbd, 0x89, 0xf9, 0x45, 0x29, 0x91, 0x9f, 0x45, 0xf6, 0x68, 0x19, 0xc2, 0x35, 0xdb, 0xc0,
	0x7c, 0xbc, 0xde, 0x23, 0x9d, 0x3e, 0x80, 0xed, 0x9c, 0xb1, 0x99, 0xbd, 0x0c, 0x64, 0x71, 0x88,
	0xcd, 0xe6, 0xca, 0xf1, 0x3a, 0x5f, 0x07, 0x36, 0xb5, 0x75, 0xd9, 0xc7, 0x37, 0x11, 0xce, 0x26,
	0xc3, 0x3c, 0x5e, 0x29, 0x56, 0xe7, 0xb8, 0x04, 0xc8, 0x3c, 0xc8, 0x1a, 0x37, 0x3d, 0x9d, 0xf3,
	0xbd, 0x69, 0xaf, 0x1a, 0xae, 0x93, 0x0d, 0xa0, 0x32, 0xb3, 0x1f, 0xbb, 0x7f, 0x23, 0xcd, 0x9c,
	0xe1, 0xcd, 0xc6, 0x8a, 0xd1, 0x2a, 0x53, 0xa7, 0x4c, 0x3f, 0x30, 0x1f, 0xfd, 0x17, 0x00, 0x00,
	0xff, 0xff, 0xf7, 0x5f, 0x79, 0xae, 0xdd, 0x0b, 0x00, 0x00,
}
