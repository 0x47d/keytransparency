// Code generated by protoc-gen-go.
// source: proto/security_ctmap/security_ctmap.proto
// DO NOT EDIT!

/*
Package security_ctmap is a generated protocol buffer package.

It is generated from these files:
	proto/security_ctmap/security_ctmap.proto

It has these top-level messages:
	EpochHead
	SignedEpochHead
	DigitallySigned
	GetLeafRequest
	GetLeafResponse
	UpdateLeafRequest
	UpdateLeafResponse
	MutationEntry
*/
package security_ctmap

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import security_protobuf "github.com/google/e2e-key-server/proto/security_protobuf"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DigitallySigned_HashAlgorithm int32

const (
	DigitallySigned_NONE   DigitallySigned_HashAlgorithm = 0
	DigitallySigned_MD5    DigitallySigned_HashAlgorithm = 1
	DigitallySigned_SHA1   DigitallySigned_HashAlgorithm = 2
	DigitallySigned_SHA224 DigitallySigned_HashAlgorithm = 3
	DigitallySigned_SHA256 DigitallySigned_HashAlgorithm = 4
	DigitallySigned_SHA384 DigitallySigned_HashAlgorithm = 5
	DigitallySigned_SHA512 DigitallySigned_HashAlgorithm = 6
)

var DigitallySigned_HashAlgorithm_name = map[int32]string{
	0: "NONE",
	1: "MD5",
	2: "SHA1",
	3: "SHA224",
	4: "SHA256",
	5: "SHA384",
	6: "SHA512",
}
var DigitallySigned_HashAlgorithm_value = map[string]int32{
	"NONE":   0,
	"MD5":    1,
	"SHA1":   2,
	"SHA224": 3,
	"SHA256": 4,
	"SHA384": 5,
	"SHA512": 6,
}

func (x DigitallySigned_HashAlgorithm) String() string {
	return proto.EnumName(DigitallySigned_HashAlgorithm_name, int32(x))
}
func (DigitallySigned_HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 0}
}

type DigitallySigned_SignatureAlgorithm int32

const (
	DigitallySigned_ANONYMOUS DigitallySigned_SignatureAlgorithm = 0
	DigitallySigned_RSA       DigitallySigned_SignatureAlgorithm = 1
	DigitallySigned_DSA       DigitallySigned_SignatureAlgorithm = 2
	DigitallySigned_ECDSA     DigitallySigned_SignatureAlgorithm = 3
)

var DigitallySigned_SignatureAlgorithm_name = map[int32]string{
	0: "ANONYMOUS",
	1: "RSA",
	2: "DSA",
	3: "ECDSA",
}
var DigitallySigned_SignatureAlgorithm_value = map[string]int32{
	"ANONYMOUS": 0,
	"RSA":       1,
	"DSA":       2,
	"ECDSA":     3,
}

func (x DigitallySigned_SignatureAlgorithm) String() string {
	return proto.EnumName(DigitallySigned_SignatureAlgorithm_name, int32(x))
}
func (DigitallySigned_SignatureAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 1}
}

// EpochHead is the head node of the Merkle Tree as well as additional metadata
// for the tree.
type EpochHead struct {
	// realm is the domain identifier for the transparent map.
	Realm string `protobuf:"bytes,1,opt,name=realm" json:"realm,omitempty"`
	// epoch number
	Epoch int64 `protobuf:"varint,2,opt,name=epoch" json:"epoch,omitempty"`
	// root is the value of the root node of the merkle tree.
	Root []byte `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// issue_time is the time when this epoch was released. Monotonically increasing.
	IssueTime *security_protobuf.Timestamp `protobuf:"bytes,4,opt,name=issue_time,json=issueTime" json:"issue_time,omitempty"`
}

func (m *EpochHead) Reset()                    { *m = EpochHead{} }
func (m *EpochHead) String() string            { return proto.CompactTextString(m) }
func (*EpochHead) ProtoMessage()               {}
func (*EpochHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EpochHead) GetIssueTime() *security_protobuf.Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return nil
}

// SignedEpochHead represents a signed state of the Merkel tree.
type SignedEpochHead struct {
	EpochHead *EpochHead `protobuf:"bytes,1,opt,name=epoch_head,json=epochHead" json:"epoch_head,omitempty"`
	// Signature of head, using the signature type of the key.
	// keyed by the first 64 bits bytes of the hash of the key.
	// TODO: Limit 1. Servers should only sign with one key at a time.
	// TODO: Create separate data structure for aggregating signatures from monitors.
	Signatures map[string]*DigitallySigned `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SignedEpochHead) Reset()                    { *m = SignedEpochHead{} }
func (m *SignedEpochHead) String() string            { return proto.CompactTextString(m) }
func (*SignedEpochHead) ProtoMessage()               {}
func (*SignedEpochHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SignedEpochHead) GetEpochHead() *EpochHead {
	if m != nil {
		return m.EpochHead
	}
	return nil
}

func (m *SignedEpochHead) GetSignatures() map[string]*DigitallySigned {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type DigitallySigned struct {
	// 1 byte
	HashAlgorithm DigitallySigned_HashAlgorithm `protobuf:"varint,1,opt,name=hash_algorithm,json=hashAlgorithm,enum=security_ctmap.DigitallySigned_HashAlgorithm" json:"hash_algorithm,omitempty"`
	// 1 byte
	SigAlgorithm DigitallySigned_SignatureAlgorithm `protobuf:"varint,2,opt,name=sig_algorithm,json=sigAlgorithm,enum=security_ctmap.DigitallySigned_SignatureAlgorithm" json:"sig_algorithm,omitempty"`
	// 0..2^16-1 bytes
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// GetLeafRequest for a verifiable map leaf.
type GetLeafRequest struct {
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch" json:"epoch,omitempty"`
}

func (m *GetLeafRequest) Reset()                    { *m = GetLeafRequest{} }
func (m *GetLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeafRequest) ProtoMessage()               {}
func (*GetLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// GetLeafResponse for a verifiable map leaf.
type GetLeafResponse struct {
	LeafData []byte `protobuf:"bytes,1,opt,name=leaf_data,json=leafData,proto3" json:"leaf_data,omitempty"`
	// neighbors is a list of all the adjacent nodes along the path
	// from the bottommost node to the head.
	Neighbors [][]byte `protobuf:"bytes,2,rep,name=neighbors,proto3" json:"neighbors,omitempty"`
}

func (m *GetLeafResponse) Reset()                    { *m = GetLeafResponse{} }
func (m *GetLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeafResponse) ProtoMessage()               {}
func (*GetLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// UpdateLeafRequest submits a change for the value at index.
type UpdateLeafRequest struct {
	Index    []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Mutation []byte `protobuf:"bytes,2,opt,name=mutation,proto3" json:"mutation,omitempty"`
}

func (m *UpdateLeafRequest) Reset()                    { *m = UpdateLeafRequest{} }
func (m *UpdateLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateLeafRequest) ProtoMessage()               {}
func (*UpdateLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// UpdateLeafResponse returns the current value of index.
type UpdateLeafResponse struct {
	Proof *GetLeafResponse `protobuf:"bytes,1,opt,name=proof" json:"proof,omitempty"`
}

func (m *UpdateLeafResponse) Reset()                    { *m = UpdateLeafResponse{} }
func (m *UpdateLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateLeafResponse) ProtoMessage()               {}
func (*UpdateLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateLeafResponse) GetProof() *GetLeafResponse {
	if m != nil {
		return m.Proof
	}
	return nil
}

// MutationEntry is either a mutation or an epoch advancement.
type MutationEntry struct {
	// Types that are valid to be assigned to Type:
	//	*MutationEntry_Update
	//	*MutationEntry_AdvanceEpoch
	Type isMutationEntry_Type `protobuf_oneof:"type"`
}

func (m *MutationEntry) Reset()                    { *m = MutationEntry{} }
func (m *MutationEntry) String() string            { return proto.CompactTextString(m) }
func (*MutationEntry) ProtoMessage()               {}
func (*MutationEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isMutationEntry_Type interface {
	isMutationEntry_Type()
}

type MutationEntry_Update struct {
	Update *UpdateLeafRequest `protobuf:"bytes,1,opt,name=update,oneof"`
}
type MutationEntry_AdvanceEpoch struct {
	AdvanceEpoch bool `protobuf:"varint,2,opt,name=advance_epoch,json=advanceEpoch,oneof"`
}

func (*MutationEntry_Update) isMutationEntry_Type()       {}
func (*MutationEntry_AdvanceEpoch) isMutationEntry_Type() {}

func (m *MutationEntry) GetType() isMutationEntry_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *MutationEntry) GetUpdate() *UpdateLeafRequest {
	if x, ok := m.GetType().(*MutationEntry_Update); ok {
		return x.Update
	}
	return nil
}

func (m *MutationEntry) GetAdvanceEpoch() bool {
	if x, ok := m.GetType().(*MutationEntry_AdvanceEpoch); ok {
		return x.AdvanceEpoch
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MutationEntry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MutationEntry_OneofMarshaler, _MutationEntry_OneofUnmarshaler, _MutationEntry_OneofSizer, []interface{}{
		(*MutationEntry_Update)(nil),
		(*MutationEntry_AdvanceEpoch)(nil),
	}
}

func _MutationEntry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MutationEntry)
	// type
	switch x := m.Type.(type) {
	case *MutationEntry_Update:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Update); err != nil {
			return err
		}
	case *MutationEntry_AdvanceEpoch:
		t := uint64(0)
		if x.AdvanceEpoch {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("MutationEntry.Type has unexpected type %T", x)
	}
	return nil
}

func _MutationEntry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MutationEntry)
	switch tag {
	case 1: // type.update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UpdateLeafRequest)
		err := b.DecodeMessage(msg)
		m.Type = &MutationEntry_Update{msg}
		return true, err
	case 2: // type.advance_epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &MutationEntry_AdvanceEpoch{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _MutationEntry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MutationEntry)
	// type
	switch x := m.Type.(type) {
	case *MutationEntry_Update:
		s := proto.Size(x.Update)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MutationEntry_AdvanceEpoch:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*EpochHead)(nil), "security_ctmap.EpochHead")
	proto.RegisterType((*SignedEpochHead)(nil), "security_ctmap.SignedEpochHead")
	proto.RegisterType((*DigitallySigned)(nil), "security_ctmap.DigitallySigned")
	proto.RegisterType((*GetLeafRequest)(nil), "security_ctmap.GetLeafRequest")
	proto.RegisterType((*GetLeafResponse)(nil), "security_ctmap.GetLeafResponse")
	proto.RegisterType((*UpdateLeafRequest)(nil), "security_ctmap.UpdateLeafRequest")
	proto.RegisterType((*UpdateLeafResponse)(nil), "security_ctmap.UpdateLeafResponse")
	proto.RegisterType((*MutationEntry)(nil), "security_ctmap.MutationEntry")
	proto.RegisterEnum("security_ctmap.DigitallySigned_HashAlgorithm", DigitallySigned_HashAlgorithm_name, DigitallySigned_HashAlgorithm_value)
	proto.RegisterEnum("security_ctmap.DigitallySigned_SignatureAlgorithm", DigitallySigned_SignatureAlgorithm_name, DigitallySigned_SignatureAlgorithm_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for VerifiableMapService service

type VerifiableMapServiceClient interface {
	// GetLeaf retrieves the value stored at a particular index.
	GetLeaf(ctx context.Context, in *GetLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error)
	// UpdateLeaf submits a change to the value at index. Clients retry until
	// change is visble in GetLeafResponse.
	UpdateLeaf(ctx context.Context, in *UpdateLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error)
}

type verifiableMapServiceClient struct {
	cc *grpc.ClientConn
}

func NewVerifiableMapServiceClient(cc *grpc.ClientConn) VerifiableMapServiceClient {
	return &verifiableMapServiceClient{cc}
}

func (c *verifiableMapServiceClient) GetLeaf(ctx context.Context, in *GetLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error) {
	out := new(GetLeafResponse)
	err := grpc.Invoke(ctx, "/security_ctmap.VerifiableMapService/GetLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableMapServiceClient) UpdateLeaf(ctx context.Context, in *UpdateLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error) {
	out := new(GetLeafResponse)
	err := grpc.Invoke(ctx, "/security_ctmap.VerifiableMapService/UpdateLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VerifiableMapService service

type VerifiableMapServiceServer interface {
	// GetLeaf retrieves the value stored at a particular index.
	GetLeaf(context.Context, *GetLeafRequest) (*GetLeafResponse, error)
	// UpdateLeaf submits a change to the value at index. Clients retry until
	// change is visble in GetLeafResponse.
	UpdateLeaf(context.Context, *UpdateLeafRequest) (*GetLeafResponse, error)
}

func RegisterVerifiableMapServiceServer(s *grpc.Server, srv VerifiableMapServiceServer) {
	s.RegisterService(&_VerifiableMapService_serviceDesc, srv)
}

func _VerifiableMapService_GetLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableMapServiceServer).GetLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security_ctmap.VerifiableMapService/GetLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableMapServiceServer).GetLeaf(ctx, req.(*GetLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableMapService_UpdateLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableMapServiceServer).UpdateLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security_ctmap.VerifiableMapService/UpdateLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableMapServiceServer).UpdateLeaf(ctx, req.(*UpdateLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VerifiableMapService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "security_ctmap.VerifiableMapService",
	HandlerType: (*VerifiableMapServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLeaf",
			Handler:    _VerifiableMapService_GetLeaf_Handler,
		},
		{
			MethodName: "UpdateLeaf",
			Handler:    _VerifiableMapService_UpdateLeaf_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("proto/security_ctmap/security_ctmap.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x54, 0xdd, 0x6e, 0xd3, 0x58,
	0x10, 0x6e, 0x7e, 0x1b, 0x4f, 0x93, 0xd4, 0x7b, 0xd4, 0x8b, 0x6c, 0xb6, 0xda, 0x5d, 0x2c, 0x21,
	0xc1, 0x45, 0x13, 0xd5, 0x6d, 0x50, 0x45, 0xb9, 0x20, 0x90, 0x88, 0x08, 0x9a, 0x16, 0x39, 0x2d,
	0x08, 0x09, 0x11, 0x9d, 0x24, 0x93, 0xd8, 0xc2, 0x89, 0x83, 0x7d, 0x5c, 0x11, 0xf1, 0x02, 0x3c,
	0x10, 0x8f, 0x87, 0x10, 0xe3, 0xe3, 0x93, 0x9f, 0xba, 0x42, 0xb9, 0x9b, 0x6f, 0xce, 0xcc, 0x37,
	0xdf, 0x8c, 0x67, 0x0c, 0x8f, 0xe7, 0xbe, 0x27, 0xbc, 0x7a, 0x80, 0xc3, 0xd0, 0x77, 0xc4, 0xa2,
	0x3f, 0x14, 0x53, 0x3e, 0x4f, 0xc0, 0x9a, 0x8c, 0x61, 0xe5, 0xbb, 0xde, 0x6a, 0x67, 0xe2, 0x08,
	0x3b, 0x1c, 0xd4, 0x86, 0xde, 0xb4, 0x3e, 0xf1, 0xbc, 0x89, 0x8b, 0x75, 0x34, 0xf1, 0xe8, 0x33,
	0x2e, 0x8e, 0x02, 0xf4, 0x6f, 0xd1, 0xaf, 0x27, 0xb8, 0x25, 0x1c, 0x84, 0xe3, 0xba, 0x70, 0xa6,
	0x18, 0x08, 0x3e, 0x55, 0xcc, 0xc6, 0xf7, 0x14, 0x68, 0xed, 0xb9, 0x37, 0xb4, 0x3b, 0xc8, 0x47,
	0xec, 0x00, 0x72, 0x3e, 0x72, 0x77, 0x5a, 0x49, 0xfd, 0x9f, 0x7a, 0xa4, 0x59, 0x31, 0x88, 0xbc,
	0x18, 0x85, 0x54, 0xd2, 0xe4, 0xcd, 0x58, 0x31, 0x60, 0x0c, 0xb2, 0xbe, 0xe7, 0x89, 0x4a, 0x86,
	0x9c, 0x45, 0x4b, 0xda, 0xec, 0x1c, 0xc0, 0x09, 0x82, 0x10, 0xfb, 0x51, 0x99, 0x4a, 0x96, 0x5e,
	0xf6, 0xcc, 0xc3, 0xda, 0x52, 0x45, 0x6d, 0xa9, 0xa2, 0x76, 0xbd, 0x54, 0x61, 0x69, 0x32, 0x3e,
	0xc2, 0xc6, 0xcf, 0x14, 0xec, 0xf7, 0x9c, 0xc9, 0x0c, 0x47, 0x6b, 0x41, 0x67, 0x00, 0xb2, 0x5a,
	0xdf, 0x26, 0x24, 0x55, 0xed, 0x99, 0x7f, 0xd7, 0x12, 0x33, 0x5a, 0x85, 0x5b, 0x1a, 0xae, 0x32,
	0xaf, 0x00, 0x02, 0x22, 0xe3, 0x22, 0xf4, 0x31, 0x20, 0xe5, 0x19, 0xca, 0xac, 0x27, 0x33, 0x13,
	0xe5, 0x24, 0x8e, 0x33, 0xda, 0x33, 0xe1, 0x2f, 0xac, 0x0d, 0x8a, 0xea, 0xa7, 0x58, 0xdd, 0xc6,
	0x33, 0xd3, 0x21, 0x43, 0x23, 0x57, 0xc3, 0x8a, 0x4c, 0xd6, 0x80, 0xdc, 0x2d, 0x77, 0x43, 0x94,
	0xa3, 0xda, 0x33, 0xff, 0x4b, 0x16, 0x6c, 0x39, 0xf4, 0xe5, 0xb8, 0xeb, 0x2e, 0xe2, 0xca, 0x56,
	0x1c, 0xfd, 0x34, 0x7d, 0x96, 0x32, 0x7e, 0xa5, 0x61, 0x3f, 0xf1, 0xcc, 0xae, 0xa1, 0x6c, 0xf3,
	0xc0, 0xee, 0x73, 0x77, 0xe2, 0x11, 0x8b, 0x1d, 0x7f, 0x98, 0xb2, 0x79, 0xb4, 0x85, 0xb7, 0xd6,
	0xa1, 0xac, 0xe6, 0x32, 0xc9, 0x2a, 0xd9, 0x9b, 0x90, 0xbd, 0x87, 0x12, 0xf5, 0xb5, 0x41, 0x9a,
	0x96, 0xa4, 0xe6, 0x36, 0xd2, 0x55, 0xfb, 0x6b, 0xe6, 0x22, 0x11, 0xad, 0x89, 0x0f, 0x41, 0x5b,
	0x0d, 0x4c, 0xed, 0xc5, 0xda, 0x61, 0x7c, 0x84, 0xd2, 0x1d, 0x59, 0xac, 0x00, 0xd9, 0xcb, 0xab,
	0xcb, 0xb6, 0xbe, 0xc3, 0x76, 0x21, 0xd3, 0x6d, 0x35, 0xf4, 0x54, 0xe4, 0xea, 0x75, 0x9a, 0xc7,
	0x7a, 0x9a, 0x01, 0xe4, 0xc9, 0x32, 0xcd, 0x53, 0x3d, 0xb3, 0xb4, 0x1b, 0x4f, 0xf4, 0xac, 0xb2,
	0x4f, 0xce, 0x4e, 0xf5, 0x9c, 0xb2, 0x1b, 0xc7, 0xa6, 0x9e, 0x37, 0x9e, 0x03, 0xbb, 0xaf, 0x8f,
	0x95, 0x40, 0x6b, 0x52, 0x8d, 0x0f, 0xdd, 0xab, 0x9b, 0x5e, 0x5c, 0xc7, 0xea, 0x35, 0xa9, 0x0e,
	0x19, 0x2d, 0x32, 0xd2, 0x4c, 0x83, 0x5c, 0xfb, 0x65, 0x64, 0x66, 0x8c, 0x67, 0x50, 0x7e, 0x85,
	0xe2, 0x02, 0xf9, 0xd8, 0xc2, 0x2f, 0x21, 0xed, 0x67, 0xb4, 0xf8, 0xce, 0x6c, 0x84, 0x5f, 0xe5,
	0xd4, 0x8b, 0x56, 0x0c, 0xee, 0x9e, 0x43, 0x56, 0x9d, 0x83, 0x71, 0x01, 0xfb, 0xab, 0xec, 0x60,
	0xee, 0xcd, 0x02, 0x64, 0xff, 0x80, 0xe6, 0x12, 0xee, 0x8f, 0xb8, 0xe0, 0x8a, 0xa2, 0x10, 0x39,
	0x5a, 0x84, 0xa3, 0x59, 0xcd, 0xd0, 0x99, 0xd8, 0x03, 0xcf, 0x8f, 0xd7, 0x93, 0x66, 0xb5, 0x72,
	0x18, 0x6d, 0xf8, 0xeb, 0x66, 0x4e, 0x79, 0xb8, 0x5d, 0x4e, 0x15, 0x0a, 0xd3, 0x50, 0x70, 0xe1,
	0x78, 0x33, 0xa9, 0x88, 0x8a, 0x2c, 0xb1, 0xf1, 0x06, 0xd8, 0x26, 0x8d, 0xd2, 0x45, 0x4b, 0x4a,
	0x97, 0xe8, 0x8d, 0xd5, 0x3d, 0xdd, 0x5b, 0xd2, 0x44, 0x1f, 0x56, 0x1c, 0x6d, 0x7c, 0x83, 0x52,
	0x57, 0x11, 0xc7, 0xeb, 0x7f, 0x0e, 0xf9, 0x50, 0xb2, 0x2b, 0xa2, 0x07, 0x49, 0xa2, 0x7b, 0x2d,
	0x74, 0x76, 0x2c, 0x95, 0xc2, 0x1e, 0x42, 0x89, 0x8f, 0x6e, 0xf9, 0x6c, 0x88, 0xfd, 0xf5, 0x34,
	0x0b, 0x14, 0x50, 0x54, 0x6e, 0x79, 0x95, 0x2f, 0xf2, 0x90, 0x15, 0x8b, 0x39, 0x9a, 0x3f, 0x52,
	0x70, 0xf0, 0x0e, 0x7d, 0x67, 0xec, 0xf0, 0x81, 0x8b, 0x5d, 0x3e, 0xef, 0xd1, 0x7f, 0xce, 0x19,
	0x22, 0x7b, 0x0d, 0xbb, 0x4a, 0x2f, 0xfb, 0xf7, 0x8f, 0x8d, 0xc8, 0xe2, 0xd5, 0x6d, 0x8d, 0xb2,
	0xb7, 0x00, 0x6b, 0xc9, 0x6c, 0x7b, 0x3b, 0x5b, 0x19, 0x07, 0x79, 0xf9, 0xcb, 0x3b, 0xf9, 0x1d,
	0x00, 0x00, 0xff, 0xff, 0x82, 0x3a, 0xe1, 0xa9, 0xec, 0x05, 0x00, 0x00,
}
